# FP16转FP32乘法器模块

## 模块概述

本模块实现了一个高性能的FP16到FP32浮点乘法器，支持32组并行计算。该模块将两个FP16数相乘，结果输出为FP32格式，满足IEEE 754标准。

## 功能特性

- **并行计算能力**: 支持32组FP16乘法同时进行
- **双寄存器组**: 每个源寄存器支持2个寄存器组
- **标准兼容**: 符合IEEE 754浮点运算标准
- **特殊值处理**: 正确处理NaN、无穷大、零值、非规格化数等特殊情况

## 文件结构

```
03_fp16mul/
├── README.md                          # 本文件
├── testplan.md                        # 测试计划文档
├── fp16mul.v                          # 主设计文件
├── tb_fp16mul.v                        # testbench文件
├── softfloat_dpi.c                    # SoftFloat DPI接口
├── run_sim.sh                         # 仿真运行脚本
└── sim_output/                        # 仿真输出目录
```

## 寄存器映射

### 输入寄存器（源操作数A：FP16_A）
- `SMC[*]/DR-FP16MUL-S0[x]`: FP16_A的位[3:0]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-S1[x]`: FP16_A的位[7:4]，x=0,1,...31  
- `SMC[*]/DR-FP16MUL-S2[x]`: FP16_A的位[11:8]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-S3[x]`: FP16_A的位[15:12]，x=0,1,...31

### 输入寄存器（源操作数B：FP16_B）
- `SMC[*]/DR-FP16MUL-S4[y]`: FP16_B的位[3:0]，y=0,1,...31
- `SMC[*]/DR-FP16MUL-S5[y]`: FP16_B的位[7:4]，y=0,1,...31
- `SMC[*]/DR-FP16MUL-S6[y]`: FP16_B的位[11:8]，y=0,1,...31
- `SMC[*]/DR-FP16MUL-S7[y]`: FP16_B的位[15:12]，y=0,1,...31

### 输出寄存器（结果：FP32）
- `SMC[*]/DR-FP16MUL-D0[x]`: FP32结果的位[3:0]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D1[x]`: FP32结果的位[7:4]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D2[x]`: FP32结果的位[11:8]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D3[x]`: FP32结果的位[15:12]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D4[x]`: FP32结果的位[19:16]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D5[x]`: FP32结果的位[23:20]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D6[x]`: FP32结果的位[27:24]，x=0,1,...31
- `SMC[*]/DR-FP16MUL-D7[x]`: FP32结果的位[31:28]，x=0,1,...31

## 运算方程

```
{SMC[*]/DR-FP16MUL-D7[x], SMC[*]/DR-FP16MUL-D6[x], SMC[*]/DR-FP16MUL-D5[x], SMC[*]/DR-FP16MUL-D4[x], 
 SMC[*]/DR-FP16MUL-D3[x], SMC[*]/DR-FP16MUL-D2[x], SMC[*]/DR-FP16MUL-D1[x], SMC[*]/DR-FP16MUL-D0[x]} = 
numpy.multiply(
{SMC[*]/DR-FP16MUL-S3[x], SMC[*]/DR-FP16MUL-S2[x], SMC[*]/DR-FP16MUL-S1[x], SMC[*]/DR-FP16MUL-S0[x]}, 
{SMC[*]/DR-FP16MUL-S7[y], SMC[*]/DR-FP16MUL-S6[y], SMC[*]/DR-FP16MUL-S5[y], SMC[*]/DR-FP16MUL-S4[y]})
```

其中x=0,1,...31，y=0,1,...31

## 控制信号

### cru_fp16mul_s0123[1:0]
- `[1]`: 有效位，1=有效写入，0=无效
- `[0]`: 寄存器组选择，0=寄存器组0，1=寄存器组1

### cru_fp16mul_s4567[3:0]  
- `[3]`: 有效位，1=有效写入，0=无效
- `[2]`: 寄存器组选择，0=寄存器组0，1=寄存器组1
- `[1:0]`: 寄存器选择，00=S4，01=S5，10=S6，11=S7

### cru_fp16mul[2:0]
- `[2]`: 乘法有效位，1=执行乘法，0=无操作
- `[1]`: S0-S3寄存器组选择，0=寄存器组0，1=寄存器组1
- `[0]`: S4-S7寄存器组选择，0=寄存器组0，1=寄存器组1

## 时序要求

1. **数据写入阶段**  
   - 写入 S0–S3 寄存器组：1 个时钟周期（`cru_fp16mul_s0123[1]` 拉高 1 拍即可完成所选 bank 四段 nibble 的整体写入）  
   - 写入 S4–S7 寄存器：每段 1 个时钟周期；若 4 段都需更新，总计 4 拍（依次发 `S4,S5,S6,S7`，通过 `cru_fp16mul_s4567[1:0]` 选择）  
   - 若某些段无需更新，可只写需要变化的段，其余沿用旧值

2. **计算阶段**  
   - 发起乘法指令：`cru_fp16mul[2]` 拉高 1 拍。该拍锁存所选 bank 数据到内部寄存器 `selected_*_r` ；组合乘法逻辑同拍产生结果（仍需 1 拍后写出）  

3. **结果输出阶段**  
   - 流水线输出延迟：1 拍（`compute_valid_r` 对 `cru_fp16mul[2]` 延迟 1 拍触发结果写回）  

4. **吞吐能力**  
   - 在没有新的数据相关 hazard（写后立刻算同一 bank）时，可做到每拍发起一条乘法指令，持续输出（启动延迟 1 拍，之后吞吐率 1 / cycle）

5. **典型调度示意**  
   | Cycle | 动作 | 说明 |
   |-------|------|------|
   | t0 | 写 S0–S3 | `cru_fp16mul_s0123` 有效 |
   | t1 | 写 S4 | `cru_fp16mul_s4567` which=00 |
   | t2 | 写 S5 | which=01 |
   | t3 | 写 S6 | which=10 |
   | t4 | 写 S7 | which=11 (最后一段) |
   | t5 | 发起计算 | `cru_fp16mul` 有效（本拍锁存 bank 数据） |
   | t6 | 结果可用 | `dr_fp16mul_d0~d7` 更新 |

6. **数据相关（RAW）提示**  
   - 若在 t4 就发起计算（与写 S7 同拍），本次计算仍会使用 S7 写入前的数据；因此需要插入 1 拍（即 t5 发起）才能使用最新 S7。其它段同理。


## 接口信号

| 信号名 | 方向 | 位宽 | 描述 |
|--------|------|------|------|
| clk | 输入 | 1 | 时钟信号 |
| rst_n | 输入 | 1 | 异步复位，低有效 |
| dvr_fp16mul_s0 | 输入 | 128 | S0数据输入 |
| dvr_fp16mul_s1 | 输入 | 128 | S1数据输入 |
| dvr_fp16mul_s2 | 输入 | 128 | S2数据输入 |
| dvr_fp16mul_s3 | 输入 | 128 | S3数据输入 |
| dvr_fp16mul_s4567 | 输入 | 128 | S4-S7复用数据输入 |
| cru_fp16mul_s0123 | 输入 | 2 | S0-S3控制信号 |
| cru_fp16mul_s4567 | 输入 | 4 | S4-S7控制信号 |
| cru_fp16mul | 输入 | 3 | 乘法控制信号 |
| dr_fp16mul_d0~d7 | 输出 | 128 | 结果输出寄存器 |

## 设计参数

```verilog
localparam PARAM_DR_FP16MUL_CNT = 32;      // fp16乘法器数量
localparam PARAM_DR_FP16MUL_S0_CNT = 2;    // s0-s3寄存器数量  
localparam PARAM_DR_FP16MUL_S1_CNT = 2;    // s4-s7寄存器数量
```

### 运行仿真

```bash
cd /home/sunny/SMC/03_fp16mul
./run_sim.sh
```


