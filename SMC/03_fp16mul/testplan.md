# FP16转FP32乘法器测试计划

## 测试目标

验证 FP16→FP32 并行乘法器的：
1. 功能正确性（含特殊值/NaN 等语义）
2. 寄存器组更新与 bank 选择逻辑
3. 时序与流水线约束（写→算→出结果）
4. 在大规模随机输入下的稳定性

## 测试环境

- 仿真器: Synopsys VCS
- 参考模型: DPI-C 调 Berkeley SoftFloat（round to nearest even）
- 时钟: 100MHz (10ns 周期)
- 复位: 低有效，多脉冲 0→1→0→1（最终保持 1）

## 当前 testbench 已实现的测试集合

源码 `tb_fp16mul.v` 中实际存在 3 个主任务：

### 1. S0123 整 bank 更新逻辑测试 (test_s0123_update_logic)
**目的**: 验证一次写入 128b×4 (S0..S3) 能正确拆装 32 组 FP16 A 操作数，并验证 bank 间独立性。

**流程**:
1. 随机生成 bank0 A、bank0 B
2. 写 S0..S3 bank0（1 拍）与 S4..S7 bank0（4 段写）
3. 发起计算 (使用 bank0/bank0)
4. 再写 bank1 A、bank1 B
5. 计算 bank1/bank1
6. 回头再算 bank0/bank0 确认未被破坏

**覆盖点**:
- S0..S3 一次性打包写入正确分拆
- S4..S7 全写一次后组合正确
- bank0 与 bank1 内容互不影响

### 2. S4567 分段渐进更新逻辑测试 (test_s4567_update_logic)
**目的**: 验证 S4..S7 分 4 个 which 段依次写入时，已写段保持、未写段沿用旧值，计算逐步反映最新组合。

**流程**:
1. 写好 A bank0
2. 依次写 which=0/1/2/3 的 B 段，每写完一段立即发起一次计算
3. 对每次结果用 SoftFloat 比对

**覆盖点**:
- 部分写入可见性
- 旧段保持不被覆盖
- 指令发起需与写入隔 1 拍才能看到最新段（满足设计锁存机制）

### 3. 交叉 bank 随机组合大规模测试 (test_cross_bank_compute_random)
**配置**: 迭代次数：30000（代码中参数）

**目的**: 大量随机数据下覆盖 (A_bank, B_bank) ∈ {(0,0),(0,1),(1,0),(1,1)} 四种组合，提升 corner case（NaN/Inf/Denorm）触发概率。

**流程**(每次迭代):
1. 随机生成 A0,A1,B0,B1（32×FP16）
2. 写入 bank0 / bank1 的 A 与 B
3. 依次发起 (0,0),(0,1),(1,0),(1,1) 四种计算
4. SoftFloat 比对并计数

**覆盖点**:
- 双 bank 交叉选择矩阵
- 大量随机统计
- 流水线在频繁 bank 切换下的稳定性

### 结果判定策略
函数 `verify_result` 允许 (NaN vs NaN) 视为通过；其余需 bit-level 匹配。统计 PASS/FAIL/总数并给出通过率。

## 时序与流水线说明（与 README 同步）
1. S0–S3 写：有效信号拉高 1 拍即可；同拍四段 nibble 全部覆盖目标 bank。
2. S4–S7 写：每段独立 1 拍；只需更新改变的段，可跳过不变段。
3. 计算发起：`cru_fp16mul[2]` 拉高的那一拍锁存所选 bank 数据到内部 `selected_*_r`。
4. 结果写回：下一拍（延迟 1 cycle）输出到 D0~D7；因此“发起后下一个上升沿”即可读。
5. Hazard 规则：想用“刚写”的那组数据，写入与计算至少隔 1 拍；否则本次计算仍用旧值。
6. 吞吐：若没有写后立即算的相关冲突，可做到每拍发起一次乘法，流水线 steady-state 吞吐 1 op/cycle。

## 覆盖率目标

- Bank 交叉组合: 100%
- 32 组并行数据路径: 100%（在每次计算中全部激活）
- S4567 分段写路径: which=0..3 全覆盖
- A/B bank 双缓冲: 读路径覆盖 (0/1)
- NaN/Inf/Denorm 覆盖

## 代码与功能覆盖指标
- 行覆盖 >95%
- 分支覆盖 >90%
- 信号翻转 >90%

