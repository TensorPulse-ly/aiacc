# FP32 8通道5输入加法器树设计规格书

## 1. 概述

### 1.1 项目描述
本项目实现了一个高性能的IEEE 754单精度浮点（FP32）5输入加法器树，能够在8个并行通道上对5个32位浮点数进行累加运算。设计采用华莱士树（Wallace Tree）架构实现高效的多输入并行累加，具有完整的IEEE 754标准兼容性和特殊值处理能力。

### 1.2 设计目标
- **高性能**: 采用华莱士树结构实现8通道并行5输入FP32累加
- **IEEE 754兼容**: 完全遵循IEEE 754-2008单精度浮点标准
- **特殊值处理**: 正确处理±0、±∞、NaN、非规格化数等特殊值
- **高精度**: 使用扩展精度位和保护位确保计算精度
- **寄存器接口**: 提供标准化的寄存器式输入输出接口

## 2. 架构设计

### 2.1 顶层架构
输入接口层 → 数据解包层 → 对齐层 → 华莱士树累加层 → 规格化舍入层 → 输出打包层
    ↓            ↓         ↓         ↓             ↓           ↓
  寄存器式     FP32解包   指数对齐   正负分离累加    规格化舍入   结果选择输出
   输入接口    特殊值检测  尾数对齐   华莱士树加法    IEEE舍入    寄存器输出


### 2.2 核心模块组成

| 模块名称 | 功能描述 | 输入 | 输出 |
|---------|---------|------|------|
| `fp32_unpacker` | FP32解包和特殊值检测 | 32位FP32数据 | 符号、指数、尾数、特殊值标志 |
| `fp32_aligner` | 指数对齐和尾数扩展 | 5组解包数据 | 最大指数、对齐后尾数 |
| `wallace_tree_5_inputs` | 华莱士树累加器 | 5个扩展精度数据 | 累加结果 |
| `fp32_normalizer_rounder` | 规格化和舍入 | 原始累加结果 | 规格化FP32结果 |
| `fp32_packer` | 结果打包 | 符号、指数、尾数 | 最终FP32输出 |

## 3. 接口规格

### 3.1 模块接口定义

module fp32_adder_tree_final (
    input  wire        clk,                             // 时钟信号
    input  wire        rst_n,                           // 低电平有效复位
    input  wire        cru_fp32addtree5to1,             // 指令有效位
    
    // 8x128-bit 源寄存器
    input  wire [127:0] dvr_fp32addtree5to1_s0,        // 输入数据寄存器0（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s1,        // 输入数据寄存器1（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s2,        // 输入数据寄存器2（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s3,        // 输入数据寄存器3（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s4,        // 输入数据寄存器4（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s5,        // 输入数据寄存器5（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s6,        // 输入数据寄存器6（每通道4位）
    input  wire [127:0] dvr_fp32addtree5to1_s7,        // 输入数据寄存器7（每通道4位）

    // 2x128-bit 目标寄存器
    output reg  [127:0] dr_fp32addtree5to1_d0,         // 输出数据寄存器0（低16位）
    output reg  [127:0] dr_fp32addtree5to1_d1          // 输出数据寄存器1（高16位）
);

### 3.2 输入接口详述

#### 3.2.1 数据输入接口
- **dvr_fp32addtree5to1_s0~s7[127:0]**: 8个源寄存器，每个128位
  - 每个寄存器包含8个通道的数据，每个通道4位
  - 8个寄存器组合提供每个通道的32位FP32数据的高4位到低4位

- **数据重组**: 每个通道的FP32数据由8个源寄存器的相应位段组合而成
  - FP32[i] = {s7[4*i +: 4], s6[4*i +: 4], ..., s1[4*i +: 4], s0[4*i +: 4]}

#### 3.2.2 控制接口
- **cru_fp32addtree5to1**: 指令有效位
  - 1'b1: 执行加法运算
  - 1'b0: 不执行运算

### 3.3 输出接口
- **dr_fp32addtree5to1_d0, dr_fp32addtree5to1_d1**: 2个128位输出寄存器
  - 每个包含8个通道的结果，每个通道16位
  - 完整的FP32结果由两个寄存器的相应位段组合：{d1[16*i +: 16], d0[16*i +: 16]}

## 4. 算法实现
1. 数据预处理阶段
   ├── 输入数据重组：S0~S7 → 8个通道各5个完整FP32数据
   ├── FP32解包：提取符号、指数、尾数
   └── 特殊值检测：识别±0、±∞、NaN

2. 对齐阶段  
   ├── 寻找最大指数：max_exponent = max(exp[0]...exp[4])
   ├── 尾数右移对齐：mant[i] >> (max_exp - exp[i])
   └── 添加保护位：Guard + Round + Sticky + 额外精度位

3. 符号处理阶段
   ├── 正数组：effective_sign = 0 的尾数
   ├── 负数组：effective_sign = 1 的尾数  
   └── 扩展到FULL_SUM_WIDTH位宽

4. 华莱士树累加阶段
   ├── 正数华莱士树：5个正数 → pos_sum
   ├── 负数华莱士树：5个负数 → neg_sum
   └── 结果相减：final_result = pos_sum - neg_sum

5. 规格化舍入阶段
   ├── 符号确定：基于final_result和输入分析
   ├── 尾数规格化：移位到标准形式
   ├── 指数调整：补偿移位造成的指数变化
   └── IEEE舍入：就近偶数舍入

6. 特殊值处理阶段
   ├── NaN传播：任意输入NaN → 输出NaN
   ├── 无穷大处理：±∞输入的特殊逻辑
   ├── 溢出处理：结果过大 → ±∞
   └── 下溢处理：结果过小 → 非规格化数

7. 结果输出阶段
   ├── 最终打包：组装符号、指数、尾数
   └── 寄存器写入：在下一个时钟周期存储到目标寄存器

## 5. 技术参数

| 参数名称 | 数值 | 说明 |
|---------|------|------|
| FP32_WIDTH | 32 | IEEE 754单精度总位宽 |
| FP32_EXP_WIDTH | 8 | 指数位宽 |
| FP32_MANT_WIDTH | 23 | 尾数位宽 |
| FP32_BIAS | 127 | 指数偏置值 |
| GUARD_BITS | 6 | 保护位数量（G+R+S+额外精度） |
| ALIGNED_MANT_WIDTH | 30 | 对齐后尾数位宽（1+23+6） |
| FULL_SUM_WIDTH | 31 | 累加器位宽 |
| NUM_LANES | 8 | 并行通道数 |
| NUM_INPUTS | 5 | 每通道输入数 |

## 6. 验证策略

### 6.1 验证环境
- **参考模型**: Berkeley SoftFloat-3库
- **验证平台**: Verilog + DPI-C
- **舍入模式**: IEEE 754就近偶数舍入

### 6.2 验收标准
- 固定测试用例100%通过
- 随机测试通过率≥99.9%
- 特殊值处理100%正确

## 快速入门指南

### 1. 克隆项目
```bash
git clone git@github.com:seclabBupt/aiacc.git
cd SMC/04_fp32_addtree_5to1
```
### 2. 运行仿真
```bash
chmod +x run_sim.sh
./run_sim.sh
```
### 3. 查看结果
```bash
# 查看仿真日志
cat sim_output/sim.log

# 使用波形查看器
gtkwave sim_output/waveform.vcd
```