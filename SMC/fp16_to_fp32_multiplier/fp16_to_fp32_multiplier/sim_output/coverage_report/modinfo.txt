===============================================================================
Module : tb_fp16_to_fp32_multiplier
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 70.28  90.24 --      70.59 --      50.00 

Source File(s) : 

/home/Sunny/SMC/fp16_to_fp32_multiplier/fp16_to_fp32_multiplier/tb_fp16_to_fp32_multiplier.v

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                       
 70.28  90.24 --      70.59 --      50.00 tb_fp16_to_fp32_multiplier 



-------------------------------------------------------------------------------
Line Coverage for Module : tb_fp16_to_fp32_multiplier

             Line No.   Total   Covered  Percent
TOTAL                      123      111    90.24
ROUTINE            31        1        0     0.00
ROUTINE            32        1        0     0.00
ROUTINE            33        1        0     0.00
ROUTINE            34        1        0     0.00
INITIAL            61        4        4   100.00
INITIAL            67       12        8    66.67
INITIAL            99      103       99    96.12

30                      //import "DPI-C" function int unsigned fp16_mul_to_fp32_softfloat(input shortint unsigned a, input shortint unsigned b);
31         0/1     ==>  import "DPI-C" function int unsigned fp16_inputs_mul_to_fp32_softfloat(input shortint unsigned a, input shortint unsigned b);
32         0/1     ==>  import "DPI-C" function void set_softfloat_rounding_mode(input int unsigned mode);
33         0/1     ==>  import "DPI-C" function void clear_softfloat_flags();
34         0/1     ==>  import "DPI-C" function int unsigned get_softfloat_flags();
35                      
36                      // SoftFloat 舍入模式 (来自 softfloat_types.h)
37                      localparam SOFTFLOAT_ROUND_NEAR_EVEN = 0; // 四舍五入到最近的偶数
38                      localparam SOFTFLOAT_ROUND_MINMAG    = 1; // 向零舍入
39                      localparam SOFTFLOAT_ROUND_MIN       = 2; // 向负无穷大舍入
40                      localparam SOFTFLOAT_ROUND_MAX       = 3; // 向正无穷大舍入
41                      localparam SOFTFLOAT_ROUND_NEAR_MAXMAG = 4; // 四舍五入到最近，关系到最大幅度
42                      // 文件句柄
43                      integer sim_log;
44                      integer coverage_log;
45                      integer pass_count;
46                      integer fail_count;
47                      
48                      // 实例化被测模块
49                      fp16_to_fp32_multiplier uut (
50                          .clk(clk),
51                          .rst_n(rst_n),
52                          .fp16_a(fp16_a),
53                          .fp16_b(fp16_b),
54                          .valid_in(valid_in),
55                          .fp32_out(fp32_out),
56                          .valid_out(valid_out)
57                      );
58                      
59                      // 时钟生成
60                      initial begin
61         1/1              clk = 0;
62         3/3              forever #5 clk = ~clk;
63                      end
64                      
65                      // 打开日志文件
66                      initial begin
67         1/1              sim_log = $fopen("sim.log", "w");
68         1/1              coverage_log = $fopen("sim.coverage.tcl", "w");
69         1/1              if (!sim_log) begin
70         0/1     ==>          $display("Error: Could not open sim.log");
71         0/1     ==>          $finish;
72                          end
                        MISSING_ELSE
73         1/1              if (!coverage_log) begin
74         0/1     ==>          $display("Error: Could not open sim.coverage.tcl");
75         0/1     ==>          $finish;
76                          end
                        MISSING_ELSE
77         1/1              $fdisplay(sim_log, "Simulation started at time %t", $time);
78         1/1              pass_count = 0;
79         1/1              fail_count = 0;
80                      
81                          // 设置 SoftFloat 舍入模式 (例如，四舍五入到最近的偶数)
82         1/1              set_softfloat_rounding_mode(SOFTFLOAT_ROUND_NEAR_EVEN);
83                      end
84                      
85                      // 测试用例
86                      reg [15:0] test_cases_a [0:29]; // 增加测试用例数量
87                      reg [15:0] test_cases_b [0:29];
88                      // reg [31:0] expected_results [0:29]; // 期望结果现在将来自 SoftFloat
89                      integer i;
90                      
91                      // Declare the missing variable 'expected_fp32_from_softfloat' as an integer
92                      integer expected_fp32_from_softfloat;
93                      
94                      // Remove 'automatic' and declare 'softfloat_flags' as an integer
95                      integer softfloat_flags;
96                      
97                      initial begin
98                          // 基本规格化数测试
99         1/1              test_cases_a[0] = 16'h3c00; // 1.0
100        1/1              test_cases_b[0] = 16'h3c00; // 1.0
101                     
102        1/1              test_cases_a[1] = 16'h4000; // 2.0
103        1/1              test_cases_b[1] = 16'h3c00; // 1.0
104                     
105        1/1              test_cases_a[2] = 16'h3c00; // 1.0
106        1/1              test_cases_b[2] = 16'h4000; // 2.0
107                     
108        1/1              test_cases_a[3] = 16'h7bff; // 最大规格化数
109        1/1              test_cases_b[3] = 16'h3c00; // 1.0
110                     
111        1/1              test_cases_a[4] = 16'h0400; // 最小规格化数
112        1/1              test_cases_b[4] = 16'h3c00; // 1.0
113                     
114                         // 无穷大测试
115        1/1              test_cases_a[5] = 16'h7c00; // +Inf
116        1/1              test_cases_b[5] = 16'h3c00; // 1.0
117                     
118        1/1              test_cases_a[6] = 16'h3c00; // 1.0
119        1/1              test_cases_b[6] = 16'h7c00; // +Inf
120                     
121        1/1              test_cases_a[7] = 16'h7c00; // +Inf
122        1/1              test_cases_b[7] = 16'h7c00; // +Inf
123                     
124                         // NaN测试
125        1/1              test_cases_a[8] = 16'h7c01; // NaN
126        1/1              test_cases_b[8] = 16'h3c00; // 1.0
127                     
128        1/1              test_cases_a[9] = 16'h3c00; // 1.0
129        1/1              test_cases_b[9] = 16'h7c01; // NaN
130                     
131                         // 零测试
132        1/1              test_cases_a[10] = 16'h0000; // +0
133        1/1              test_cases_b[10] = 16'h3c00; // 1.0
134                     
135        1/1              test_cases_a[11] = 16'h3c00; // 1.0
136        1/1              test_cases_b[11] = 16'h0000; // +0
137                     
138        1/1              test_cases_a[12] = 16'h8000; // -0
139        1/1              test_cases_b[12] = 16'h3c00; // 1.0
140                     
141                         // 非规格化数测试
142        1/1              test_cases_a[13] = 16'h0001; // 最小非规格化数
143        1/1              test_cases_b[13] = 16'h3c00; // 1.0
144                     
145        1/1              test_cases_a[14] = 16'h03ff; // 最大非规格化数
146        1/1              test_cases_b[14] = 16'h3c00; // 1.0
147                     
148                         // 增加更多规格化数测试
149        1/1              test_cases_a[15] = 16'h4400; // 4.0 
150        1/1              test_cases_b[15] = 16'h4400; // 4.0 
151                     
152        1/1              test_cases_a[16] = 16'h4400; // 4.0 
153        1/1              test_cases_b[16] = 16'h4500; // 5.0
154                     
155        1/1              test_cases_a[17] = 16'h4400; // 4.0
156        1/1              test_cases_b[17] = 16'h3e00; // 1.5
157                     
158        1/1              test_cases_a[18] = 16'h3800; // 0.5
159        1/1              test_cases_b[18] = 16'h3800; // 0.5
160                     
161        1/1              test_cases_a[19] = 16'h4400; // 4.0 
162        1/1              test_cases_b[19] = 16'hc000; // -2.0
163                     
164        1/1              test_cases_a[20] = 16'hbc00; // -1.0
165        1/1              test_cases_b[20] = 16'hbc00; // -1.0
166                     
167        1/1              test_cases_a[21] = 16'h5400; // 64.0 
168        1/1              test_cases_b[21] = 16'h5400; // 64.0 
169                     
170        1/1              test_cases_a[22] = 16'h4800; // 8.0 
171        1/1              test_cases_b[22] = 16'h3400; // 0.25 
172                     
173                         // 添加测试边界情况的规格化数
174        1/1              test_cases_a[23] = 16'h0400; // 2^-14 (最小规格化数)
175        1/1              test_cases_b[23] = 16'h0400; // 2^-14 (最小规格化数)
176                     
177        1/1              test_cases_a[24] = 16'h7800; // 2^15 
178        1/1              test_cases_b[24] = 16'h0400; // 2^-14 (最小规格化数)
179                     
180        1/1              test_cases_a[25] = 16'h0400; // 2^-14 (最小规格化数)
181        1/1              test_cases_b[25] = 16'h7800; // 2^15 
182                     
183                         // 测试指数接近上限/下限的情况
184        1/1              test_cases_a[26] = 16'h7800; // 2^15 
185        1/1              test_cases_b[26] = 16'h7800; // 2^15 
186                     
187                         // 新 Case 27: 大数乘以小数 (2^15 * 2^-13 = 2^2)
188        1/1              test_cases_a[27] = 16'h7800; // 2^15 (最大正指数规格化数)
189        1/1              test_cases_b[27] = 16'h0800; // 2^-13
190                     
191                         // 尾数全1的情况测试
192        1/1              test_cases_a[28] = 16'h3bff; // 1.0 - epsilon
193        1/1              test_cases_b[28] = 16'h4000; // 2.0
194                     
195                         // 测试舍入
196        1/1              test_cases_a[29] = 16'h3c01; // 1.0 + epsilon
197        1/1              test_cases_b[29] = 16'h3c01; // 1.0 + epsilon
198                     
199                     
200                         // 复位
201        1/1              rst_n = 0;
202        1/1              valid_in = 0;
203        1/1              fp16_a = 0;
204        1/1              fp16_b = 0;
205        2/2              #20;
206        1/1              rst_n = 1;
207        2/2              #10;
208                     
209                         // 运行测试用例
210        1/1              for (i = 0; i < 30; i = i + 1) begin
211        1/1                  fp16_a = test_cases_a[i];
212        1/1                  fp16_b = test_cases_b[i];
213        1/1                  valid_in = 1;
214                             
215                             // 在每次操作前清除 SoftFloat 异常标志
216        1/1                  clear_softfloat_flags();
217                             
218                             // 通过 DPI-C 从 SoftFloat 获取期望结果
219        1/1                  expected_fp32_from_softfloat = fp16_inputs_mul_to_fp32_softfloat(fp16_a, fp16_b);
220        1/1                  softfloat_flags = get_softfloat_flags();
221                     
222        2/2                  #10; // 等待 DUT 处理输入 (如果 DUT 有延迟则调整)
223                             
224                             // 等待一个时钟周期后检查结果
225                             // 最好等待 valid_out 或固定的延迟
226                             // 本示例假设为组合逻辑 DUT 或 1 周期延迟
227                             // 对于流水线 DUT，您需要一种更可靠的方法来对齐期望结果和实际结果。
228                             
229                             // 如果您的 DUT 使用 valid_out，则等待它
230                             // 现在，我们假设结果在几个周期后可用
231                             // 这部分需要根据您的 DUT 行为进行调整。
232                             // 示例: wait(valid_out === 1); 
233                             // 或者，如果是固定延迟，例如 # (NUM_CYCLES_LATENCY * CLK_PERIOD);
234                     
235        1/1                  if (valid_out) begin // 如果DUT的输出有效 (valid_out 为高)
236        1/1                      if (fp32_out !== expected_fp32_from_softfloat) begin
237                                     // 处理 NaN 的比较：NaN 从不等于 NaN。
238                                     // 如果两个值都是 NaN (指数位全1，尾数位非零)，那么对于NaN来说它们是匹配的。
239                                     logic is_expected_nan, is_fp32_out_nan;
240        1/1                          is_expected_nan = (expected_fp32_from_softfloat[30:23] == 8'hFF) && (expected_fp32_from_softfloat[22:0] != 0);
241        1/1                          is_fp32_out_nan   = (fp32_out[30:23] == 8'hFF) && (fp32_out[22:0] != 0);
242                     
243        1/1                          if (is_expected_nan && is_fp32_out_nan) begin
244        1/1                              $fdisplay(sim_log, "用例 %0d: PASS (NaN): a=%h, b=%h, softfloat=%h (标志=%h), 实际值=%h", 
245                                                  i, fp16_a, fp16_b, expected_fp32_from_softfloat, softfloat_flags, fp32_out);
246        1/1                              pass_count = pass_count + 1;
247                                     end else begin
248        0/1     ==>                      $fdisplay(sim_log, "用例 %0d: FAIL: a=%h, b=%h, softfloat=%h (标志=%h), 实际值=%h", 
249                                                  i, fp16_a, fp16_b, expected_fp32_from_softfloat, softfloat_flags, fp32_out);
250        0/1     ==>                      fail_count = fail_count + 1;
251                                     end
252                                 end else begin
253        1/1                          $fdisplay(sim_log, "用例 %0d: PASS: a=%h, b=%h, softfloat=%h (标志=%h), 实际值=%h", 
254                                              i, fp16_a, fp16_b, expected_fp32_from_softfloat, softfloat_flags, fp32_out);
255        1/1                          pass_count = pass_count + 1;
256                                 end
257                             end else begin
258                                 // 如果在检查结果时 valid_out 未置位，则可能进入此 'else' 分支。
259                                 // 这可能是因为 valid_in 被过早地取消置位，或者 valid_out 的逻辑与预期不符。
260        0/1     ==>              $fdisplay(sim_log, "用例 %0d: 警告: 检查时 valid_out 未有效。 a=%h, b=%h. Softfloat  %h (标志=%h). DUT 输出 %h.",
261                                                    i, fp16_a, fp16_b, expected_fp32_from_softfloat, softfloat_flags, fp32_out);
262                                 // 根据严格程度，这可能被视为一个失败。
263                                 // fail_count = fail_count + 1; 
264                             end
265                             
266        1/1                  valid_in = 0;
267        2/2                  #10;
268                         end
269                     
270                         // 输出统计信息
271        1/1              $fdisplay(sim_log, "\nTest Summary:");
272        1/1              $fdisplay(sim_log, "Total tests: %0d", pass_count + fail_count);
273        1/1              $fdisplay(sim_log, "Passed: %0d", pass_count);
274        1/1              $fdisplay(sim_log, "Failed: %0d", fail_count);
275                         
276        1/1              if (fail_count == 0) begin
277        1/1                  $fdisplay(sim_log, "\nPASSED: All test cases passed!");
278                         end else begin
279        0/1     ==>          $fdisplay(sim_log, "\nFAILED: %0d test cases failed", fail_count);
280                         end
281                         
282                         // 关闭文件
283        1/1              $fclose(sim_log);
284        1/1              $fclose(coverage_log);
285        1/1              $finish;

-------------------------------------------------------------------------------
Toggle Coverage for Module : tb_fp16_to_fp32_multiplier
                Total Covered Percent 
Totals          7     4       57.14   
Total Bits      136   96      70.59   
Total Bits 0->1 68    49      72.06   
Total Bits 1->0 68    47      69.12   

                               
Signals          7   4  57.14  
Signal Bits      136 96 70.59  
Signal Bits 0->1 68  49 72.06  
Signal Bits 1->0 68  47 69.12  

Signal Details
                Toggle Toggle 1->0 Toggle 0->1 
clk             Yes    Yes         Yes         
rst_n           No     No          Yes         
fp16_a[15:0]    Yes    Yes         Yes         
fp16_b[0]       Yes    Yes         Yes         
fp16_b[7:1]     No     No          No          
fp16_b[15:8]    Yes    Yes         Yes         
valid_in        Yes    Yes         Yes         
fp32_out[2:0]   No     No          No          
fp32_out[3]     No     No          Yes         
fp32_out[12:4]  No     No          No          
fp32_out[31:13] Yes    Yes         Yes         
valid_out       Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : tb_fp16_to_fp32_multiplier
         Line No. Total Covered Percent 
Branches          6     3       50.00   
IF       69       2     1       50.00   
IF       73       2     1       50.00   
IF       276      2     1       50.00   


69             if (!sim_log) begin
               -1-  
70                 $display("Error: Could not open sim.log");
                   ==>
71                 $finish;
72             end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


73             if (!coverage_log) begin
               -1-  
74                 $display("Error: Could not open sim.coverage.tcl");
                   ==>
75                 $finish;
76             end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


276            if (fail_count == 0) begin
               -1-  
277                $fdisplay(sim_log, "\nPASSED: All test cases passed!");
                   ==>
278            end else begin
279                $fdisplay(sim_log, "\nFAILED: %0d test cases failed", fail_count);
                   ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_fp16_to_fp32_multiplier
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 70.28  90.24 --      70.59 --      50.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 75.90  91.18  80.95  69.58 --      61.90 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                       
 70.28  90.24 --      70.59 --      50.00 tb_fp16_to_fp32_multiplier 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME 
 78.54 100.00  80.95  69.34 --      63.89 uut  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : fp16_to_fp32_multiplier
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 78.54 100.00  80.95  69.34 --      63.89 

Source File(s) : 

/home/Sunny/SMC/fp16_to_fp32_multiplier/fp16_to_fp32_multiplier/fp16_to_fp32_multiplier.v

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                           
 78.54 100.00  80.95  69.34 --      63.89 tb_fp16_to_fp32_multiplier.uut 



-------------------------------------------------------------------------------
Line Coverage for Module : fp16_to_fp32_multiplier

             Line No.   Total   Covered  Percent
TOTAL                       13       13   100.00
ROUTINE            56        6        6   100.00
ALWAYS            142        7        7   100.00

55                          begin
56         1/1                  count = 0;
57         1/1                  temp = value;
58                              // 修正循环条件
59         1/1                  while (count < 21 && temp[21] == 1'b0 && temp != 0) begin
60         1/1                      count = count + 1;
61         1/1                      temp = temp << 1;
62                              end
                   ==>  WHILE_FALSE
63         1/1                  count_leading_zeros = count;
64                          end
65                      endfunction
66                      
67                      // =========================== 处理尾数 =========================
68                      // 规格化数的隐含前导1，非规格化数则为0
69                      wire [FP16_MANT_WIDTH:0] mant_a_with_hidden = a_is_denorm ? {1'b0, mant_a} : {1'b1, mant_a};
70                      wire [FP16_MANT_WIDTH:0] mant_b_with_hidden = b_is_denorm ? {1'b0, mant_b} : {1'b1, mant_b};
71                      
72                      
73                      // 执行尾数乘法，结果为22位
74                      wire [2*(FP16_MANT_WIDTH+1)-1:0] mant_product = mant_a_with_hidden * mant_b_with_hidden;
75                      
76                      // 改进的规格化检测
77                      wire normalize_shift = mant_product[2*(FP16_MANT_WIDTH+1)-1];
78                      
79                      // 表明是否需要处理非规格化数
80                      wire need_denorm_handling = a_is_denorm || b_is_denorm;
81                      // 计算前导零数量
82                      wire [4:0] leading_zeros = count_leading_zeros(mant_product);
83                      
84                      
85                      wire [21:0] shifted_mant = (mant_product == 0) ? 22'b0 :
86                                                 (need_denorm_handling) ? ((leading_zeros >= 22) ? 22'b0 : (mant_product << leading_zeros)) :
87                                                 (normalize_shift) ? (mant_product >> 1) :
88                                                 mant_product;
89                      
90                      // final_mant的计算
91                      wire [FP32_MANT_WIDTH-1:0] final_mant = 
92                          (mant_product == 0) ? 23'b0 :
93                          need_denorm_handling ? 
94                              {shifted_mant[20:0], 2'b00} :     // 取高21位，补2个0
95                          normalize_shift ? 
96                              {mant_product[20:0], 2'b00} :     // 取高21位，补2个0
97                              {mant_product[19:0], 3'b00}; 
98                      
99                      // ================================ 指数计算 ===========================
100                     // 非规格化数的无偏指数为-14（等于1-偏置）
101                     wire signed [7:0] exp_a_unbiased = a_is_denorm ? -14 : {3'b000, exp_a} - FP16_BIAS;
102                     wire signed [7:0] exp_b_unbiased = b_is_denorm ? -14 : {3'b000, exp_b} - FP16_BIAS;
103                     
104                     // 计算输出无偏指数，加上规格化调整
105                     // 需要确保位宽足够容纳两个8位有符号数的和以及1位normalize_shift
106                     wire signed [9:0] exp_out_unbiased = {{2{exp_a_unbiased[7]}}, exp_a_unbiased} + 
107                                                          {{2{exp_b_unbiased[7]}}, exp_b_unbiased} ;
108                     // 修改指数调整逻辑
109                     wire signed [9:0] exp_adjustment = 
110                         need_denorm_handling ? 
111                             (mant_product == 0) ? 10'd0 :
112                             -{{5{1'b0}}, leading_zeros} + {9'b0, shifted_mant[21]} :
113                         normalize_shift ? 10'd1 : 10'd0;
114                     
115                     // 添加FP32偏置得到偏置指数
116                     wire signed [9:0] exp_out_biased = exp_out_unbiased + exp_adjustment + FP32_BIAS;
117                     
118                     // 处理指数溢出和下溢
119                     wire exp_overflow = exp_out_biased > 254;
120                     wire exp_underflow = exp_out_biased < 1;
121                      
122                     // 确保所有位都有明确的赋值（不会有X值）
123                     wire [FP32_MANT_WIDTH-1:0] mant_out = 
124                         output_is_zero   ? {FP32_MANT_WIDTH{1'b0}} :     // 零
125                         output_is_inf    ? {FP32_MANT_WIDTH{1'b0}} :     // 无穷大
126                         output_is_nan    ? {1'b1, {(FP32_MANT_WIDTH-1){1'b0}}} : // NaN
127                         exp_overflow     ? {FP32_MANT_WIDTH{1'b0}} :     // 溢出到无穷大
128                         exp_underflow    ? {FP32_MANT_WIDTH{1'b0}} :     // 下溢到零
129                         final_mant;                                      // 正常情况
130                     
131                     // 最终指数值，考虑特殊情况
132                     wire [FP32_EXP_WIDTH-1:0] exp_out = 
133                         output_is_zero   ? 8'd0 :                  // 零
134                         output_is_inf    ? 8'd255 :                // 无穷大
135                         output_is_nan    ? 8'd255 :                // NaN
136                         exp_overflow     ? 8'd255 :                // 溢出到无穷大
137                         exp_underflow    ? 8'd0 :                  // 下溢到零或非规格化（此处简化为零）
138                         exp_out_biased[7:0];                       // 正常情况
139                     
140                     // 输出寄存
141                     always @(posedge clk or negedge rst_n) begin
142        1/1              if (!rst_n) begin
143                             // 复位状态
144        1/1                  fp32_out <= 32'd0;
145        1/1                  valid_out <= 1'b0;
146        1/1              end else if (valid_in) begin
147                             // 根据IEEE 754标准构建FP32输出
148        1/1                  fp32_out <= {sign_out, exp_out, mant_out};
149        1/1                  valid_out <= 1'b1;
150                         end else begin
151        1/1                  valid_out <= 1'b0;

-------------------------------------------------------------------------------
Cond Coverage for Module : fp16_to_fp32_multiplier

               Total   Covered  Percent
Conditions         84       68    80.95
Logical            84       68    80.95
Non-Logical         0        0
Event               0        0

 LINE       32
 EXPRESSION ((exp_a == 5'b0) && (mant_a == 10'b0))
             -------1-------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       33
 EXPRESSION ((exp_b == 5'b0) && (mant_b == 10'b0))
             -------1-------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Not Covered
 1   1  Covered

 LINE       34
 EXPRESSION (a_is_zero || b_is_zero)
             ----1----    ----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       36
 EXPRESSION ((exp_a == 5'b11111) && (mant_a == 10'b0))
             ---------1---------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       37
 EXPRESSION ((exp_b == 5'b11111) && (mant_b == 10'b0))
             ---------1---------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       38
 EXPRESSION (a_is_inf || b_is_inf)
             ----1---    ----2---

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       40
 EXPRESSION ((exp_a == 5'b11111) && (mant_a != 10'b0))
             ---------1---------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       41
 EXPRESSION ((exp_b == 5'b11111) && (mant_b != 10'b0))
             ---------1---------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       42
 EXPRESSION (a_is_nan || b_is_nan)
             ----1---    ----2---

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       44
 EXPRESSION ((exp_a == 5'b0) && (mant_a != 10'b0))
             -------1-------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       45
 EXPRESSION ((exp_b == 5'b0) && (mant_b != 10'b0))
             -------1-------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Not Covered

 LINE       69
 EXPRESSION (a_is_denorm ? ({1'b0, mant_a}) : ({1'b1, mant_a}))
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       70
 EXPRESSION (b_is_denorm ? ({1'b0, mant_b}) : ({1'b1, mant_b}))
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       80
 EXPRESSION (a_is_denorm || b_is_denorm)
             -----1-----    -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Covered

 LINE       85
 EXPRESSION 
 Number  Term
      1  (mant_product == 22'b0) ? 22'b0 : (need_denorm_handling ? ((leading_zeros >= 5'h16) ? 22'b0 : ((mant_product << leading_zeros))) : (normalize_shift ? ((mant_product >> 1)) : mant_product)))

-1- Status
 0  Covered
 1  Not Covered

 LINE       85
 SUB-EXPRESSION 
 Number  Term
      1  need_denorm_handling ? ((leading_zeros >= 5'h16) ? 22'b0 : ((mant_product << leading_zeros))) : (normalize_shift ? ((mant_product >> 1)) : mant_product))

-1- Status
 0  Covered
 1  Covered

 LINE       85
 SUB-EXPRESSION ((leading_zeros >= 5'h16) ? 22'b0 : ((mant_product << leading_zeros)))
                 ------------1-----------

-1- Status
 0  Covered
 1  Not Covered

 LINE       85
 SUB-EXPRESSION (normalize_shift ? ((mant_product >> 1)) : mant_product)
                 -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       91
 EXPRESSION 
 Number  Term
      1  (mant_product == 22'b0) ? 23'b0 : (need_denorm_handling ? ({shifted_mant[20:0], 2'b0}) : (normalize_shift ? ({mant_product[20:0], 2'b0}) : ({mant_product[19:0], 3'b0}))))

-1- Status
 0  Covered
 1  Not Covered

 LINE       91
 SUB-EXPRESSION (need_denorm_handling ? ({shifted_mant[20:0], 2'b0}) : (normalize_shift ? ({mant_product[20:0], 2'b0}) : ({mant_product[19:0], 3'b0})))
                 ----------1---------

-1- Status
 0  Covered
 1  Covered

 LINE       91
 SUB-EXPRESSION (normalize_shift ? ({mant_product[20:0], 2'b0}) : ({mant_product[19:0], 3'b0}))
                 -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       101
 EXPRESSION (a_is_denorm ? ((-14)) : (({3'b0, exp_a} - FP16_BIAS)))
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       102
 EXPRESSION (b_is_denorm ? ((-14)) : (({3'b0, exp_b} - FP16_BIAS)))
             -----1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       109
 EXPRESSION 
 Number  Term
      1  need_denorm_handling ? ((mant_product == 22'b0) ? 10'b0 : (((-{{5 {1'b0}}, leading_zeros}) + {9'b0, shifted_mant[21]}))) : (normalize_shift ? 10'b1 : 10'b0))

-1- Status
 0  Covered
 1  Covered

 LINE       109
 SUB-EXPRESSION ((mant_product == 22'b0) ? 10'b0 : (((-{{5 {1'b0}}, leading_zeros}) + {9'b0, shifted_mant[21]})))
                 -----------1-----------

-1- Status
 0  Covered
 1  Not Covered

 LINE       109
 SUB-EXPRESSION (normalize_shift ? 10'b1 : 10'b0)
                 -------1-------

-1- Status
 0  Covered
 1  Not Covered

 LINE       123
 EXPRESSION 
 Number  Term
      1  output_is_zero ? ({FP32_MANT_WIDTH {1'b0}}) : (output_is_inf ? ({FP32_MANT_WIDTH {1'b0}}) : (output_is_nan ? ({1'b1, {(FP32_MANT_WIDTH - 1) {1'b0}}}) : (exp_overflow ? ({FP32_MANT_WIDTH {1'b0}}) : (exp_underflow ? ({FP32_MANT_WIDTH {1'b0}}) : final_mant)))))

-1- Status
 0  Covered
 1  Covered

 LINE       123
 SUB-EXPRESSION 
 Number  Term
      1  output_is_inf ? ({FP32_MANT_WIDTH {1'b0}}) : (output_is_nan ? ({1'b1, {(FP32_MANT_WIDTH - 1) {1'b0}}}) : (exp_overflow ? ({FP32_MANT_WIDTH {1'b0}}) : (exp_underflow ? ({FP32_MANT_WIDTH {1'b0}}) : final_mant))))

-1- Status
 0  Covered
 1  Covered

 LINE       123
 SUB-EXPRESSION 
 Number  Term
      1  output_is_nan ? ({1'b1, {(FP32_MANT_WIDTH - 1) {1'b0}}}) : (exp_overflow ? ({FP32_MANT_WIDTH {1'b0}}) : (exp_underflow ? ({FP32_MANT_WIDTH {1'b0}}) : final_mant)))

-1- Status
 0  Covered
 1  Covered

 LINE       123
 SUB-EXPRESSION (exp_overflow ? ({FP32_MANT_WIDTH {1'b0}}) : (exp_underflow ? ({FP32_MANT_WIDTH {1'b0}}) : final_mant))
                 ------1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       123
 SUB-EXPRESSION (exp_underflow ? ({FP32_MANT_WIDTH {1'b0}}) : final_mant)
                 ------1------

-1- Status
 0  Covered
 1  Not Covered

 LINE       132
 EXPRESSION 
 Number  Term
      1  output_is_zero ? 8'b0 : (output_is_inf ? 8'd255 : (output_is_nan ? 8'd255 : (exp_overflow ? 8'd255 : (exp_underflow ? 8'b0 : exp_out_biased[7:0])))))

-1- Status
 0  Covered
 1  Covered

 LINE       132
 SUB-EXPRESSION (output_is_inf ? 8'd255 : (output_is_nan ? 8'd255 : (exp_overflow ? 8'd255 : (exp_underflow ? 8'b0 : exp_out_biased[7:0]))))
                 ------1------

-1- Status
 0  Covered
 1  Covered

 LINE       132
 SUB-EXPRESSION (output_is_nan ? 8'd255 : (exp_overflow ? 8'd255 : (exp_underflow ? 8'b0 : exp_out_biased[7:0])))
                 ------1------

-1- Status
 0  Covered
 1  Covered

 LINE       132
 SUB-EXPRESSION (exp_overflow ? 8'd255 : (exp_underflow ? 8'b0 : exp_out_biased[7:0]))
                 ------1-----

-1- Status
 0  Covered
 1  Not Covered

 LINE       132
 SUB-EXPRESSION (exp_underflow ? 8'b0 : exp_out_biased[7:0])
                 ------1------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : fp16_to_fp32_multiplier
                Total Covered Percent 
Totals          42    27      64.29   
Total Bits      574   398     69.34   
Total Bits 0->1 287   202     70.38   
Total Bits 1->0 287   196     68.29   

                             
Ports          7   4  57.14  
Port Bits      136 96 70.59  
Port Bits 0->1 68  49 72.06  
Port Bits 1->0 68  47 69.12  

                                
Signals          35  23  65.71  
Signal Bits      438 302 68.95  
Signal Bits 0->1 219 153 69.86  
Signal Bits 1->0 219 149 68.04  

Port Details
                Toggle Toggle 1->0 Toggle 0->1 Direction 
clk             Yes    Yes         Yes         INPUT     
rst_n           No     No          Yes         INPUT     
fp16_a[15:0]    Yes    Yes         Yes         INPUT     
fp16_b[0]       Yes    Yes         Yes         INPUT     
fp16_b[7:1]     No     No          No          INPUT     
fp16_b[15:8]    Yes    Yes         Yes         INPUT     
valid_in        Yes    Yes         Yes         INPUT     
fp32_out[2:0]   No     No          No          OUTPUT    
fp32_out[3]     No     No          Yes         OUTPUT    
fp32_out[12:4]  No     No          No          OUTPUT    
fp32_out[31:13] Yes    Yes         Yes         OUTPUT    
valid_out       Yes    Yes         Yes         OUTPUT    

Signal Details
                         Toggle Toggle 1->0 Toggle 0->1 
sign_a                   Yes    Yes         Yes         
sign_b                   Yes    Yes         Yes         
exp_a[4:0]               Yes    Yes         Yes         
exp_b[4:0]               Yes    Yes         Yes         
mant_a[9:0]              Yes    Yes         Yes         
mant_b[0]                Yes    Yes         Yes         
mant_b[7:1]              No     No          No          
mant_b[9:8]              Yes    Yes         Yes         
a_is_zero                Yes    Yes         Yes         
b_is_zero                Yes    Yes         Yes         
output_is_zero           Yes    Yes         Yes         
a_is_inf                 Yes    Yes         Yes         
b_is_inf                 Yes    Yes         Yes         
output_is_inf            Yes    Yes         Yes         
a_is_nan                 Yes    Yes         Yes         
b_is_nan                 Yes    Yes         Yes         
output_is_nan            Yes    Yes         Yes         
a_is_denorm              Yes    Yes         Yes         
b_is_denorm              No     No          No          
sign_out                 Yes    Yes         Yes         
mant_a_with_hidden[10:0] Yes    Yes         Yes         
mant_b_with_hidden[0]    Yes    Yes         Yes         
mant_b_with_hidden[7:1]  No     No          No          
mant_b_with_hidden[9:8]  Yes    Yes         Yes         
mant_b_with_hidden[10]   No     No          No          
mant_product[0]          No     No          Yes         
mant_product[9:1]        No     No          No          
mant_product[20:10]      Yes    Yes         Yes         
mant_product[21]         No     No          No          
normalize_shift          No     No          No          
need_denorm_handling     Yes    Yes         Yes         
leading_zeros[1:0]       Yes    Yes         Yes         
leading_zeros[2]         No     No          No          
leading_zeros[3]         Yes    Yes         Yes         
leading_zeros[4]         No     No          No          
shifted_mant[0]          No     No          Yes         
shifted_mant[9:1]        No     No          No          
shifted_mant[21:10]      Yes    Yes         Yes         
final_mant[2:0]          No     No          No          
final_mant[3]            No     No          Yes         
final_mant[12:4]         No     No          No          
final_mant[22:13]        Yes    Yes         Yes         
exp_a_unbiased[7:0]      Yes    Yes         Yes         
exp_b_unbiased[7:0]      Yes    Yes         Yes         
exp_out_unbiased[9:0]    Yes    Yes         Yes         
exp_adjustment[9:0]      Yes    Yes         Yes         
exp_out_biased[7:0]      Yes    Yes         Yes         
exp_out_biased[9:8]      No     No          No          
exp_overflow             No     No          No          
exp_underflow            No     No          No          
mant_out[2:0]            No     No          No          
mant_out[3]              No     No          Yes         
mant_out[12:4]           No     No          No          
mant_out[22:13]          Yes    Yes         Yes         
exp_out[7:0]             Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : fp16_to_fp32_multiplier
         Line No. Total Covered Percent 
Branches          36    23      63.89   
TERNARY  69       2     2       100.00  
TERNARY  70       2     1       50.00   
TERNARY  85       5     2       40.00   
TERNARY  91       4     2       50.00   
TERNARY  101      2     2       100.00  
TERNARY  102      2     1       50.00   
TERNARY  109      4     2       50.00   
TERNARY  123      6     4       66.67   
TERNARY  132      6     4       66.67   
IF       142      3     3       100.00  


69         wire [FP16_MANT_WIDTH:0] mant_a_with_hidden = a_is_denorm ? {1'b0, mant_a} : {1'b1, mant_a};
                                                                     -1-  
                                                                     ==>  
                                                                     ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


70         wire [FP16_MANT_WIDTH:0] mant_b_with_hidden = b_is_denorm ? {1'b0, mant_b} : {1'b1, mant_b};
                                                                     -1-  
                                                                     ==>  
                                                                     ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


85         wire [21:0] shifted_mant = (mant_product == 0) ? 22'b0 :
                                                          -1-  
                                                          ==>  
86                                    (need_denorm_handling) ? ((leading_zeros >= 22) ? 22'b0 : (mant_product << leading_zeros)) :
                                                             -2-                      -3-   
                                                                                      ==>  
                                                                                      ==>  
87                                    (normalize_shift) ? (mant_product >> 1) :
                                                        -4-  
                                                        ==>  
                                                        ==>  

Branches:

-1- -2- -3- -4- Status      
1   -   -   -   Not Covered 
0   1   1   -   Not Covered 
0   1   0   -   Covered     
0   0   -   1   Not Covered 
0   0   -   0   Covered     


91         wire [FP32_MANT_WIDTH-1:0] final_mant = 
                                                   
92             (mant_product == 0) ? 23'b0 :
                                   -1-  
                                   ==>  
93             need_denorm_handling ? 
                                    -2-  
                                    ==>  
94                 {shifted_mant[20:0], 2'b00} :     // 取高21位，补2个0
                                                                              
95             normalize_shift ? 
                               -3-  
                               ==>  
                               ==>  

Branches:

-1- -2- -3- Status      
1   -   -   Not Covered 
0   1   -   Covered     
0   0   1   Not Covered 
0   0   0   Covered     


101        wire signed [7:0] exp_a_unbiased = a_is_denorm ? -14 : {3'b000, exp_a} - FP16_BIAS;
                                                          -1-  
                                                          ==>  
                                                          ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


102        wire signed [7:0] exp_b_unbiased = b_is_denorm ? -14 : {3'b000, exp_b} - FP16_BIAS;
                                                          -1-  
                                                          ==>  
                                                          ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


109        wire signed [9:0] exp_adjustment = 
                                              
110            need_denorm_handling ? 
                                    -1-  
111                (mant_product == 0) ? 10'd0 :
                                       -2-  
                                       ==>  
                                       ==>  
112                -{{5{1'b0}}, leading_zeros} + {9'b0, shifted_mant[21]} :
                                                                           
113            normalize_shift ? 10'd1 : 10'd0;
                               -3-  
                               ==>  
                               ==>  

Branches:

-1- -2- -3- Status      
1   1   -   Not Covered 
1   0   -   Covered     
0   -   1   Not Covered 
0   -   0   Covered     


123        wire [FP32_MANT_WIDTH-1:0] mant_out = 
                                                 
124            output_is_zero   ? {FP32_MANT_WIDTH{1'b0}} :     // 零
                                -1-  
                                ==>  
125            output_is_inf    ? {FP32_MANT_WIDTH{1'b0}} :     // 无穷大
                                -2-  
                                ==>  
126            output_is_nan    ? {1'b1, {(FP32_MANT_WIDTH-1){1'b0}}} : // NaN
                                -3-  
                                ==>  
127            exp_overflow     ? {FP32_MANT_WIDTH{1'b0}} :     // 溢出到无穷大
                                -4-  
                                ==>  
128            exp_underflow    ? {FP32_MANT_WIDTH{1'b0}} :     // 下溢到零
                                -5-  
                                ==>  
                                ==>  

Branches:

-1- -2- -3- -4- -5- Status      
1   -   -   -   -   Covered     
0   1   -   -   -   Covered     
0   0   1   -   -   Covered     
0   0   0   1   -   Not Covered 
0   0   0   0   1   Not Covered 
0   0   0   0   0   Covered     


132        wire [FP32_EXP_WIDTH-1:0] exp_out = 
                                               
133            output_is_zero   ? 8'd0 :                  // 零
                                -1-  
                                ==>  
134            output_is_inf    ? 8'd255 :                // 无穷大
                                -2-  
                                ==>  
135            output_is_nan    ? 8'd255 :                // NaN
                                -3-  
                                ==>  
136            exp_overflow     ? 8'd255 :                // 溢出到无穷大
                                -4-  
                                ==>  
137            exp_underflow    ? 8'd0 :                  // 下溢到零或非规格化（此处简化为零）
                                -5-  
                                ==>  
                                ==>  

Branches:

-1- -2- -3- -4- -5- Status      
1   -   -   -   -   Covered     
0   1   -   -   -   Covered     
0   0   1   -   -   Covered     
0   0   0   1   -   Not Covered 
0   0   0   0   1   Not Covered 
0   0   0   0   0   Covered     


142            if (!rst_n) begin
               -1-  
143                // 复位状态
144                fp32_out <= 32'd0;
                   ==>
145                valid_out <= 1'b0;
146            end else if (valid_in) begin
                        -2-  
147                // 根据IEEE 754标准构建FP32输出
148                fp32_out <= {sign_out, exp_out, mant_out};
                   ==>
149                valid_out <= 1'b1;
150            end else begin
151                valid_out <= 1'b0;
                   ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_fp16_to_fp32_multiplier.uut
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 78.54 100.00  80.95  69.34 --      63.89 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 78.54 100.00  80.95  69.34 --      63.89 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                    
 78.54 100.00  80.95  69.34 --      63.89 fp16_to_fp32_multiplier 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                       
 70.28  90.24 --      70.59 --      50.00 tb_fp16_to_fp32_multiplier 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
