===============================================================================
Module : tb_fp16_to_fp32_multiplier
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 79.21  94.82 --      92.81 --      50.00 

Source File(s) : 

/home/Sunny/SMC/03_fp16_to_fp32_multiplier/tb_fp16_to_fp32_multiplier.v

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                       
 79.21  94.82 --      92.81 --      50.00 tb_fp16_to_fp32_multiplier 



-------------------------------------------------------------------------------
Line Coverage for Module : tb_fp16_to_fp32_multiplier

             Line No.   Total   Covered  Percent
TOTAL                      328      311    94.82
ROUTINE            45        1        0     0.00
ROUTINE            48        1        0     0.00
ROUTINE            49        1        0     0.00
ROUTINE            50        1        0     0.00
INITIAL            81        4        4   100.00
INITIAL            87        2        2   100.00
ROUTINE            95        6        6   100.00
ROUTINE           114        8        6    75.00
ROUTINE           142       10        8    80.00
ROUTINE           174       69       65    94.20
ROUTINE           226       18       18   100.00
ROUTINE           252       36       36   100.00
ROUTINE           273        9        9   100.00
ROUTINE           330        1        1   100.00
ROUTINE           348        8        7    87.50
ROUTINE           369       13       12    92.31
ROUTINE           402       69       67    97.10
ROUTINE           502       40       40   100.00
INITIAL           567       31       30    96.77

44                        
45         0/1     ==>    import "DPI-C" function int unsigned fp16_inputs_mul_to_fp32_softfloat(
46                          input shortint unsigned a, input shortint unsigned b
47                        );
48         0/1     ==>    import "DPI-C" function void set_softfloat_rounding_mode(input int unsigned mode);
49         0/1     ==>    import "DPI-C" function void clear_softfloat_flags();
50         0/1     ==>    import "DPI-C" function int unsigned get_softfloat_flags();
51                        
52                        integer test_count = 0;
53                        integer pass_count = 0;
54                        integer fail_count = 0;
55                        integer expected_fp32;
56                        integer softfloat_flags;
57                        integer random_num = 1000;
58                        
59                        fp16_to_fp32_multiplier uut (
60                          .clk(clk),
61                          .rst_n(rst_n),
62                          .dvr_fp16mul_s0(dvr_fp16mul_s0),
63                          .dvr_fp16mul_s1(dvr_fp16mul_s1),
64                          .dvr_fp16mul_s2(dvr_fp16mul_s2),
65                          .dvr_fp16mul_s3(dvr_fp16mul_s3),
66                          .dvr_fp16mul_s4567(dvr_fp16mul_s4567),
67                          .cru_fp16mul_s0123(cru_fp16mul_s0123),
68                          .cru_fp16mul_s4567(cru_fp16mul_s4567),
69                          .cru_fp16mul(cru_fp16mul),
70                          .dr_fp16mul_d0(dr_fp16mul_d0),
71                          .dr_fp16mul_d1(dr_fp16mul_d1),
72                          .dr_fp16mul_d2(dr_fp16mul_d2),
73                          .dr_fp16mul_d3(dr_fp16mul_d3),
74                          .dr_fp16mul_d4(dr_fp16mul_d4),
75                          .dr_fp16mul_d5(dr_fp16mul_d5),
76                          .dr_fp16mul_d6(dr_fp16mul_d6),
77                          .dr_fp16mul_d7(dr_fp16mul_d7)
78                        );
79                        
80                        initial begin : clock_gen
81         1/1              clk = 0;
82         3/3              forever #5 clk = ~clk;  // 10ns周期，100MHz
83                        end
84                        
85                        // VCD波形文件生成
86                        initial begin
87         1/1              $dumpfile("fp16_to_fp32_multiplier.vcd");
88         1/1              $dumpvars(0, tb_fp16_to_fp32_multiplier);
89                        end
90                        
91                      
92                        // 复位系统
93                        task reset_system;
94                        begin
95         1/1              rst_n = 0;
96         2/2              @(posedge clk);
97         1/1              rst_n = 1;
98         2/2              @(posedge clk);
99                        end
100                       endtask
101                       
102                     
103                       // 结果验证函数
104                       function verify_result;
105                         input [15:0] fp16_a;
106                         input [15:0] fp16_b;
107                         input [31:0] actual_result;
108                         input [31:0] expected_result; 
109                         input integer test_id;
110                         input string test_type;
111                         
112                         reg is_nan_expected, is_nan_actual;
113                       begin
114        1/1              test_count = test_count + 1;
115                         
116                         // 特殊处理NaN
117        1/1              is_nan_expected = (expected_result[30:23] == 8'hff) && (expected_result[22:0] != 0);
118        1/1              is_nan_actual = (actual_result[30:23] == 8'hff) && (actual_result[22:0] != 0);
119                         
120        1/1              if (actual_result == expected_result || (is_nan_expected && is_nan_actual)) begin
121        1/1                $display("%s测试 %0d: 通过 - a=%h, b=%h, softfloat=%h (标志=%h), 实际值=%h", 
122                                    test_type, test_id, fp16_a, fp16_b, expected_result, get_softfloat_flags(), actual_result);
123        1/1                verify_result = 1; // 通过
124                         end else begin
125        0/1     ==>        $display("%s测试 %0d: 失败 - a=%h, b=%h, softfloat=%h (标志=%h), 实际值=%h", 
126                                    test_type, test_id, fp16_a, fp16_b, expected_result, get_softfloat_flags(), actual_result);
127        0/1     ==>        verify_result = 0; // 失败
128                         end
129                       end
130                       endfunction
131                       
132                       
133                       // 测试无效指令
134                       task test_idle_instruction;
135                         input [15:0] fp16_a;
136                         input [15:0] fp16_b;
137                         input integer group_id;
138                         input integer reg_bank;
139                         
140                         reg [31:0] original_result;
141                       begin
142        1/1              $display("开始无效指令测试 (组%0d, 寄存器组%0d)...", group_id, reg_bank);
143                         
144                         // 先执行一次正常操作获取结果
145        1/1              write_fp16_to_registers(fp16_a, fp16_b, group_id, reg_bank, 1'b1);
146        1/1              original_result = reconstruct_result(group_id);
147                         
148                         // 使用无效指令尝试写入
149        1/1              write_fp16_to_registers(fp16_a, fp16_b, group_id, reg_bank, 1'b0);
150                         
151                         // 检查结果是否保持不变
152        1/1              if (reconstruct_result(group_id) === original_result) begin
153        1/1                $display("无效指令测试通过: 结果保持不变");
154        1/1                pass_count = pass_count + 1;
155                         end else begin
156        0/1     ==>        $display("无效指令测试失败: 结果被改变");
157        0/1     ==>        fail_count = fail_count + 1;
158                         end
159                         
160        1/1              test_count = test_count + 1;
161                       end
162                       endtask
163                       
164                       // 测试所有寄存器组选择组合
165                       task test_all_bank_combinations;
166                         input [15:0] a0, b0; // Bank 0 data
167                         input [15:0] a1, b1; // Bank 1 data
168                         input integer group_id;
169                     
170                         reg [31:0] actual_result;
171                         reg [31:0] expected_result;
172                         string test_name;
173                       begin
174        1/1              $display("开始所有寄存器组组合测试 (组%0d)...", group_id);
175                         
176                         // 写入数据到两个寄存器组
177        1/1              write_s0123_registers(a0, group_id, 0, 1'b1);
178        1/1              write_s4567_registers(b0, group_id, 0, 1'b1);
179        1/1              write_s0123_registers(a1, group_id, 1, 1'b1);
180        1/1              write_s4567_registers(b1, group_id, 1, 1'b1);
181                     
182                         // --- 测试组合 0 * 0 ---
183        1/1              test_name = "交叉寄存器(0*0)";
184        1/1              clear_softfloat_flags();
185        1/1              expected_result = fp16_inputs_mul_to_fp32_softfloat(a0, b0);
186        9/9              cru_fp16mul = {1'b1, 1'b0, 1'b0}; @(posedge clk); cru_fp16mul = 3'b000; @(posedge clk); repeat(2) @(posedge clk);
                        REPEAT_FALSE
187        1/1              actual_result = reconstruct_result(group_id);
188        2/3     ==>      if (verify_result(a0, b0, actual_result, expected_result, test_count, test_name)) pass_count = pass_count + 1; else fail_count = fail_count + 1;
189                     
190                         // --- 测试组合 0 * 1 ---
191        1/1              test_name = "交叉寄存器(0*1)";
192        1/1              clear_softfloat_flags();
193        1/1              expected_result = fp16_inputs_mul_to_fp32_softfloat(a0, b1);
194        9/9              cru_fp16mul = {1'b1, 1'b0, 1'b1}; @(posedge clk); cru_fp16mul = 3'b000; @(posedge clk); repeat(2) @(posedge clk);
                        REPEAT_FALSE
195        1/1              actual_result = reconstruct_result(group_id);
196        2/3     ==>      if (verify_result(a0, b1, actual_result, expected_result, test_count, test_name)) pass_count = pass_count + 1; else fail_count = fail_count + 1;
197                     
198                         // --- 测试组合 1 * 0 ---
199        1/1              test_name = "交叉寄存器(1*0)";
200        1/1              clear_softfloat_flags();
201        1/1              expected_result = fp16_inputs_mul_to_fp32_softfloat(a1, b0);
202        9/9              cru_fp16mul = {1'b1, 1'b1, 1'b0}; @(posedge clk); cru_fp16mul = 3'b000; @(posedge clk); repeat(2) @(posedge clk);
                        REPEAT_FALSE
203        1/1              actual_result = reconstruct_result(group_id);
204        2/3     ==>      if (verify_result(a1, b0, actual_result, expected_result, test_count, test_name)) pass_count = pass_count + 1; else fail_count = fail_count + 1;
205                     
206                         // --- 测试组合 1 * 1 ---
207        1/1              test_name = "交叉寄存器(1*1)";
208        1/1              clear_softfloat_flags();
209        1/1              expected_result = fp16_inputs_mul_to_fp32_softfloat(a1, b1);
210        9/9              cru_fp16mul = {1'b1, 1'b1, 1'b1}; @(posedge clk); cru_fp16mul = 3'b000; @(posedge clk); repeat(2) @(posedge clk);
                        REPEAT_FALSE
211        1/1              actual_result = reconstruct_result(group_id);
212        2/3     ==>      if (verify_result(a1, b1, actual_result, expected_result, test_count, test_name)) pass_count = pass_count + 1; else fail_count = fail_count + 1;
213                       end
214                       endtask
215                     
216                     
217                       // 仅写入s0-s3寄存器
218                       task write_s0123_registers;
219                         input [15:0] fp16_val;
220                         input integer group_id;
221                         input integer reg_bank;
222                         input instruction_valid;
223                     
224                         reg [127:0] test_s0, test_s1, test_s2, test_s3;
225                       begin
226        4/4              test_s0 = 128'h0; test_s1 = 128'h0; test_s2 = 128'h0; test_s3 = 128'h0;
227        1/1              test_s0[group_id*4 +: 4] = fp16_val[3:0];    
228        1/1              test_s1[group_id*4 +: 4] = fp16_val[7:4];    
229        1/1              test_s2[group_id*4 +: 4] = fp16_val[11:8];   
230        1/1              test_s3[group_id*4 +: 4] = fp16_val[15:12];
231                     
232        1/1              dvr_fp16mul_s0 = test_s0;
233        1/1              dvr_fp16mul_s1 = test_s1;
234        1/1              dvr_fp16mul_s2 = test_s2;
235        1/1              dvr_fp16mul_s3 = test_s3;
236        1/1              cru_fp16mul_s0123 = {instruction_valid, reg_bank[0]};
237        2/2              @(posedge clk);
238        1/1              cru_fp16mul_s0123 = 2'b00;
239        2/2              @(posedge clk);
240                       end
241                       endtask
242                     
243                       // 仅写入s4-s7寄存器
244                       task write_s4567_registers;
245                         input [15:0] fp16_val;
246                         input integer group_id;
247                         input integer reg_bank;
248                         input instruction_valid;
249                     
250                         reg [127:0] test_s4, test_s5, test_s6, test_s7;
251                       begin
252        4/4              test_s4 = 128'h0; test_s5 = 128'h0; test_s6 = 128'h0; test_s7 = 128'h0;
253        1/1              test_s4[group_id*4 +: 4] = fp16_val[3:0];    
254        1/1              test_s5[group_id*4 +: 4] = fp16_val[7:4];    
255        1/1              test_s6[group_id*4 +: 4] = fp16_val[11:8];   
256        1/1              test_s7[group_id*4 +: 4] = fp16_val[15:12]; 
257                     
258        7/7              dvr_fp16mul_s4567 = test_s4; cru_fp16mul_s4567 = {instruction_valid, reg_bank[0], 2'b00}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
259        7/7              dvr_fp16mul_s4567 = test_s5; cru_fp16mul_s4567 = {instruction_valid, reg_bank[0], 2'b01}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
260        7/7              dvr_fp16mul_s4567 = test_s6; cru_fp16mul_s4567 = {instruction_valid, reg_bank[0], 2'b10}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
261        7/7              dvr_fp16mul_s4567 = test_s7; cru_fp16mul_s4567 = {instruction_valid, reg_bank[0], 2'b11}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
262                       end
263                       endtask
264                       
265                       // 写入两个FP16到寄存器
266                       task write_fp16_to_registers;
267                         input [15:0] fp16_a;
268                         input [15:0] fp16_b;
269                         input integer group_id;
270                         input integer reg_bank;
271                         input instruction_valid;
272                       begin
273        1/1              write_s0123_registers(fp16_a, group_id, reg_bank, instruction_valid);
274        1/1              write_s4567_registers(fp16_b, group_id, reg_bank, instruction_valid);
275                         
276                         // 执行乘法运算
277        1/1              if (instruction_valid) begin
278        1/1                cru_fp16mul = {1'b1, reg_bank[0], reg_bank[0]};  // 有效信号 + 源寄存器选择
279        2/2                @(posedge clk);
280        1/1                cru_fp16mul = 3'b000;  // 清除控制信号
281        2/2                @(posedge clk);
282                         end
                        MISSING_ELSE
283                         
284                       end
285                       endtask
286                       
287                       // 写入多个组的数据
288                       task write_multiple_groups;
289                         input [15:0] fp16_a [0:31];
290                         input [15:0] fp16_b [0:31];
291                         input integer reg_bank;
292                         
293                         reg [127:0] test_s0, test_s1, test_s2, test_s3;
294                         reg [127:0] test_s4, test_s5, test_s6, test_s7;
295                         integer i;
296                       begin
297                         // 为所有组准备数据
298                         test_s0 = 128'h0; test_s1 = 128'h0; test_s2 = 128'h0; test_s3 = 128'h0;
299                         test_s4 = 128'h0; test_s5 = 128'h0; test_s6 = 128'h0; test_s7 = 128'h0;
300                         
301                         for (i = 0; i < NUM_GROUPS; i = i + 1) begin
302                           test_s0[i*4 +: 4] = fp16_a[i][3:0];   test_s1[i*4 +: 4] = fp16_a[i][7:4];
303                           test_s2[i*4 +: 4] = fp16_a[i][11:8];  test_s3[i*4 +: 4] = fp16_a[i][15:12];
304                           test_s4[i*4 +: 4] = fp16_b[i][3:0];   test_s5[i*4 +: 4] = fp16_b[i][7:4];
305                           test_s6[i*4 +: 4] = fp16_b[i][11:8];  test_s7[i*4 +: 4] = fp16_b[i][15:12];
306                         end
307                         
308                         // 写入s0-s3寄存器
309                         dvr_fp16mul_s0 = test_s0; dvr_fp16mul_s1 = test_s1;
310                         dvr_fp16mul_s2 = test_s2; dvr_fp16mul_s3 = test_s3;
311                         cru_fp16mul_s0123 = {1'b1, reg_bank[0]}; @(posedge clk);
312                         cru_fp16mul_s0123 = 2'b00; @(posedge clk);
313                         
314                         // 分别写入s4,s5,s6,s7寄存器
315                         dvr_fp16mul_s4567 = test_s4; cru_fp16mul_s4567 = {1'b1, reg_bank[0], 2'b00}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
316                         dvr_fp16mul_s4567 = test_s5; cru_fp16mul_s4567 = {1'b1, reg_bank[0], 2'b01}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
317                         dvr_fp16mul_s4567 = test_s6; cru_fp16mul_s4567 = {1'b1, reg_bank[0], 2'b10}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
318                         dvr_fp16mul_s4567 = test_s7; cru_fp16mul_s4567 = {1'b1, reg_bank[0], 2'b11}; @(posedge clk); cru_fp16mul_s4567 = 4'b0000; @(posedge clk);
319                         
320                         // 执行乘法运算
321                         cru_fp16mul = {1'b1, reg_bank[0], reg_bank[0]}; @(posedge clk); // 发起指令
322                         cru_fp16mul = 3'b000; @(posedge clk);                          
323                       end
324                       endtask
325                       
326                       // 从输出寄存器重构结果
327                       function [31:0] reconstruct_result;
328                         input integer group_id;
329                       begin
330        1/1              reconstruct_result = {
331                           dr_fp16mul_d7[group_id*4 +: 4], dr_fp16mul_d6[group_id*4 +: 4],
332                           dr_fp16mul_d5[group_id*4 +: 4], dr_fp16mul_d4[group_id*4 +: 4],
333                           dr_fp16mul_d3[group_id*4 +: 4], dr_fp16mul_d2[group_id*4 +: 4],
334                           dr_fp16mul_d1[group_id*4 +: 4], dr_fp16mul_d0[group_id*4 +: 4]
335                         };
336                       end
337                       endfunction
338                       
339                       // 固定测试任务
340                       task test_with_softfloat;
341                         input [15:0] fp16_a;
342                         input [15:0] fp16_b;
343                         input integer group_id;
344                         input integer reg_bank;
345                         
346                         reg [31:0] actual_result;
347                       begin
348        1/1              clear_softfloat_flags();
349        1/1              expected_fp32 = fp16_inputs_mul_to_fp32_softfloat(fp16_a, fp16_b);
350        1/1              softfloat_flags = get_softfloat_flags();
351        1/1              write_fp16_to_registers(fp16_a, fp16_b, group_id, reg_bank, 1'b1);
352        1/1              actual_result = reconstruct_result(group_id);
353        1/1              if (verify_result(fp16_a, fp16_b, actual_result, expected_fp32, test_count, "固定"))
354        1/1                pass_count = pass_count + 1;
355                         else
356        0/1     ==>        fail_count = fail_count + 1;
357                       end
358                       endtask
359                       
360                       // 随机测试任务
361                       task random_test;
362                         input integer num_tests;
363                         
364                         reg [15:0] random_fp16_a;
365                         reg [15:0] random_fp16_b;
366                         reg [31:0] actual_result;
367                         integer i;
368                       begin
369        1/1              $display("开始随机测试 (%0d次)...", num_tests);
370        1/1              for (i = 0; i < num_tests; i = i + 1) begin
371        1/1                random_fp16_a = $random & 16'hffff;
372        1/1                random_fp16_b = $random & 16'hffff;
373        1/1                clear_softfloat_flags();
374        1/1                expected_fp32 = fp16_inputs_mul_to_fp32_softfloat(random_fp16_a, random_fp16_b);
375        1/1                softfloat_flags = get_softfloat_flags();
376        1/1                write_fp16_to_registers(random_fp16_a, random_fp16_b, 0, 0, 1'b1);
377        1/1                actual_result = reconstruct_result(0);
378        1/1                if (verify_result(random_fp16_a, random_fp16_b, actual_result, expected_fp32, i, "随机"))
379        1/1                  pass_count = pass_count + 1;
380                           else
381        0/1     ==>          fail_count = fail_count + 1;
382                         end
383        1/1              $display("随机测试完成");
384                       end
385                       endtask
386                     
387                       // 32组同时随机测试任务 
388                       task test_32groups_simultaneous_random;
389                         input integer num_tests;
390                         
391                         reg [15:0] fp16_a_array [0:31];
392                         reg [15:0] fp16_b_array [0:31];
393                         reg [31:0] expected_array [0:31];
394                         reg [31:0] actual_array [0:31];
395                         
396                         reg [127:0] s0_data, s1_data, s2_data, s3_data;
397                         reg [127:0] s4_data, s5_data, s6_data, s7_data;
398                         
399                         integer i, j;
400                         integer passed_in_test, failed_in_test;
401                       begin
402        1/1              $display("开始32组同时随机测试 (%0d轮，每轮32组)...", num_tests);
403                         
404        1/1              for (i = 0; i < num_tests; i = i + 1) begin
405        1/1                passed_in_test = 0;
406        1/1                failed_in_test = 0;
407                           
408        1/1                for (j = 0; j < 32; j = j + 1) begin
409        1/1                  fp16_a_array[j] = $random & 16'hffff;
410        1/1                  fp16_b_array[j] = $random & 16'hffff;
411                             
412                             // 计算期望结果
413        1/1                  clear_softfloat_flags();
414        1/1                  expected_array[j] = fp16_inputs_mul_to_fp32_softfloat(fp16_a_array[j], fp16_b_array[j]);
415                           end
416                           
417                           // 将32组数据组装成128位寄存器值
418        4/4                s0_data = 128'h0; s1_data = 128'h0; s2_data = 128'h0; s3_data = 128'h0;
419        4/4                s4_data = 128'h0; s5_data = 128'h0; s6_data = 128'h0; s7_data = 128'h0;
420                           
421        1/1                for (j = 0; j < 32; j = j + 1) begin
422        1/1                  s0_data[j*4 +: 4] = fp16_a_array[j][3:0];    
423        1/1                  s1_data[j*4 +: 4] = fp16_a_array[j][7:4];    
424        1/1                  s2_data[j*4 +: 4] = fp16_a_array[j][11:8];   
425        1/1                  s3_data[j*4 +: 4] = fp16_a_array[j][15:12];  
426        1/1                  s4_data[j*4 +: 4] = fp16_b_array[j][3:0];    
427        1/1                  s5_data[j*4 +: 4] = fp16_b_array[j][7:4];    
428        1/1                  s6_data[j*4 +: 4] = fp16_b_array[j][11:8];   
429        1/1                  s7_data[j*4 +: 4] = fp16_b_array[j][15:12];  
430                           end
431                           
432                           // 第1步：写入S0-S3寄存器（FP16_A数据）
433        1/1                dvr_fp16mul_s0 = s0_data;
434        1/1                dvr_fp16mul_s1 = s1_data;
435        1/1                dvr_fp16mul_s2 = s2_data;
436        1/1                dvr_fp16mul_s3 = s3_data;
437        1/1                cru_fp16mul_s0123 = 2'b10;  // 有效写入到寄存器组0
438        2/2                @(posedge clk);
439        1/1                cru_fp16mul_s0123 = 2'b00;
440                           
441                           // 第2步：写入S4寄存器（FP16_B的低4位）
442        1/1                dvr_fp16mul_s4567 = s4_data;
443        1/1                cru_fp16mul_s4567 = 4'b1000;  // 有效写入S4到寄存器组0
444        2/2                @(posedge clk);
445        1/1                cru_fp16mul_s4567 = 4'b0000;
446                           
447                           // 第3步：写入S5寄存器（FP16_B的次低4位）
448        1/1                dvr_fp16mul_s4567 = s5_data;
449        1/1                cru_fp16mul_s4567 = 4'b1001;  // 有效写入S5到寄存器组0
450        2/2                @(posedge clk);
451        1/1                cru_fp16mul_s4567 = 4'b0000;
452                           
453                           // 第4步：写入S6寄存器（FP16_B的次高4位）
454        1/1                dvr_fp16mul_s4567 = s6_data;
455        1/1                cru_fp16mul_s4567 = 4'b1010;  // 有效写入S6到寄存器组0
456        2/2                @(posedge clk);
457        1/1                cru_fp16mul_s4567 = 4'b0000;
458                           
459                           // 第5步：写入S7寄存器（FP16_B的高4位）
460        1/1                dvr_fp16mul_s4567 = s7_data;
461        1/1                cru_fp16mul_s4567 = 4'b1011;  // 有效写入S7到寄存器组0
462        2/2                @(posedge clk);
463        1/1                cru_fp16mul_s4567 = 4'b0000;
464                           
465                           // 第6步：乘法运算指令
466        1/1                cru_fp16mul = 3'b100;  // 有效乘法指令，使用寄存器组0*寄存器组0
467        2/2                @(posedge clk);
468        1/1                cru_fp16mul = 3'b000;
469                           
470                           // 第7步：读取结果
471        2/2                @(posedge clk);  // 等待1个时钟周期让结果稳定
472                           
473                           // 从输出寄存器读取所有32组的结果
474        1/1                for (j = 0; j < 32; j = j + 1) begin
475        1/1                  actual_array[j] = {
476                               dr_fp16mul_d7[j*4 +: 4], dr_fp16mul_d6[j*4 +: 4],
477                               dr_fp16mul_d5[j*4 +: 4], dr_fp16mul_d4[j*4 +: 4],
478                               dr_fp16mul_d3[j*4 +: 4], dr_fp16mul_d2[j*4 +: 4],
479                               dr_fp16mul_d1[j*4 +: 4], dr_fp16mul_d0[j*4 +: 4]
480                             };
481                             
482                             // 验证每组的结果
483        1/1                  if (verify_result(fp16_a_array[j], fp16_b_array[j], actual_array[j], expected_array[j], test_count, "32组同时")) begin
484        1/1                    passed_in_test = passed_in_test + 1;
485        1/1                    pass_count = pass_count + 1;
486                             end else begin
487        0/1     ==>            failed_in_test = failed_in_test + 1;
488        0/1     ==>            fail_count = fail_count + 1;
489                             end
490                           end
491                           
492        1/1                $display("第%0d轮32组同时测试完成：通过%0d组，失败%0d组", i+1, passed_in_test, failed_in_test);
493                         end
494                         
495        1/1              $display("32组同时随机测试完成");
496                       end
497                       endtask
498                       
499                       // 固定测试任务 
500                       task fixed_test;
501                       begin
502        1/1              $display("开始固定测试...");
503                         // 基本规格化数测试
504        1/1              test_with_softfloat (16'h3c00, 16'h3c00, 1, 0);// 测试 1: 1.0 * 1.0 = 1.0
505        1/1              test_with_softfloat (16'h4000, 16'h3c00, 2, 0);// 测试 2: 2.0 * 1.0 = 2.0
506        1/1              test_with_softfloat (16'h3c00, 16'h4000, 3, 0);// 测试 3: 1.0 * 2.0 = 2.0
507        1/1              test_with_softfloat (16'h7bff, 16'h3c00, 4, 0);// 测试 4: max_norm * 1.0
508        1/1              test_with_softfloat (16'h0400, 16'h3c00, 5, 0);// 测试 5: min_norm * 1.0
509                     
510                         // 无穷大测试
511        1/1              test_with_softfloat (16'h7c00, 16'h3c00, 6, 0);// 测试 6: +inf * 1.0 = +inf
512        1/1              test_with_softfloat (16'h3c00, 16'h7c00, 7, 0);// 测试 7: 1.0 * +inf = +inf
513        1/1              test_with_softfloat (16'h7c00, 16'h7c00, 8, 0);// 测试 8: +inf * +inf = +inf
514                     
515                         // NaN 测试
516        1/1              test_with_softfloat (16'h7c01, 16'h3c00, 1, 1);// 测试 9: NaN * 1.0 = NaN
517        1/1              test_with_softfloat (16'h3c00, 16'h7c01, 2, 1);// 测试 10: 1.0 * NaN = NaN
518                     
519                         // 零测试
520        1/1              test_with_softfloat (16'h0000, 16'h3c00, 3, 1);// 测试 11: +0 * 1.0 = +0
521        1/1              test_with_softfloat (16'h3c00, 16'h0000, 4, 1);// 测试 12: 1.0 * +0 = +0
522        1/1              test_with_softfloat (16'h8000, 16'h3c00, 5, 1);// 测试 13: -0 * 1.0 = -0
523                     
524                         // 非规格化数测试
525        1/1              test_with_softfloat (16'h0001, 16'h3c00, 6, 1);// 测试 14: min_denorm * 1.0
526        1/1              test_with_softfloat (16'h03ff, 16'h3c00, 7, 1);// 测试 15: max_denorm * 1.0
527                     
528                         // 更多规格化数测试
529        1/1              test_with_softfloat (16'h4400, 16'h4400, 8, 1);// 测试 16: 4.0 * 4.0 = 16.0
530        1/1              test_with_softfloat (16'h4400, 16'h4500, 0, 0);// 测试 17: 4.0 * 5.0 = 20.0
531        1/1              test_with_softfloat (16'h4400, 16'h3e00, 0, 0);// 测试 18: 4.0 * 1.5 = 6.0
532        1/1              test_with_softfloat (16'h3800, 16'h3800, 0, 0);// 测试 19: 0.5 * 0.5 = 0.25
533        1/1              test_with_softfloat (16'h4400, 16'hc000, 0, 0);// 测试 20: 4.0 * -2.0 = -8.0
534                     
535                         // 负数测试
536        1/1              test_with_softfloat (16'hbc00, 16'hbc00, 0, 0);// 测试 21: -1.0 * -1.0 = 1.0
537        1/1              test_with_softfloat (16'h5400, 16'h5400, 0, 0);// 测试 22: 64.0 * 64.0 = 4096.0
538        1/1              test_with_softfloat (16'h4800, 16'h3400, 0, 0);// 测试 23: 8.0 * 0.25 = 2.0
539                     
540                         // 边界条件测试
541        1/1              test_with_softfloat (16'h0400, 16'h0400, 0, 0);// 测试 24: min_norm * min_norm -> denorm result
542        1/1              test_with_softfloat (16'h7800, 16'h0400, 0, 0);// 测试 25: 2^15 * min_norm
543        1/1              test_with_softfloat (16'h0400, 16'h7800, 0, 0);// 测试 26: min_norm * 2^15
544        1/1              test_with_softfloat (16'h7800, 16'h7800, 0, 0);// 测试 27: 2^15 * 2^15 = +inf
545        1/1              test_with_softfloat (16'h7800, 16'h0800, 0, 0);// 测试 28: 2^15 * 2^-13 = 4.0
546                     
547                         // 尾数边界情况
548        1/1              test_with_softfloat (16'h3bff, 16'h4000, 0, 0);// 测试 29: (1.0-eps) * 2.0
549        1/1              test_with_softfloat (16'h3c01, 16'h3c01, 0, 0);// 测试 30: (1.0+eps) * (1.0+eps)
550                         
551                         // 边界和特殊值组合测试
552        1/1              test_with_softfloat (16'h0001, 16'h0001, 0, 0); // min_denorm * min_denorm -> underflow to zero
553        1/1              test_with_softfloat (16'h0400, 16'h8400, 0, 0); // min_norm * -min_norm -> denormalized result
554        1/1              test_with_softfloat (16'h7c00, 16'h0000, 0, 0); // +inf * +0 -> NaN
555        1/1              test_with_softfloat (16'hfc00, 16'h7c00, 0, 0); // -inf * +inf -> -inf
556        1/1              test_with_softfloat (16'h7c01, 16'h7c00, 0, 0); // NaN * inf -> NaN
557        1/1              test_with_softfloat (16'h0000, 16'h8000, 0, 0); // +0 * -0 -> -0
558        1/1              test_with_softfloat (16'h03ff, 16'h0400, 0, 0); // max_denorm * min_norm -> normalized result
559        1/1              test_with_softfloat (16'h7bff, 16'h7bff, 0, 0); // max_norm * max_norm -> overflow to inf
560                     
561        1/1              $display("固定测试完成");
562                       end
563                       endtask
564                     
565                       initial begin 
566                     
567        1/1              set_softfloat_rounding_mode(SOFTFLOAT_ROUND_NEAR_EVEN);
568                         
569                         // 初始化信号
570        3/3              test_count = 0; pass_count = 0; fail_count = 0;
571        2/2              dvr_fp16mul_s0 = 128'h0; dvr_fp16mul_s1 = 128'h0;
572        2/2              dvr_fp16mul_s2 = 128'h0; dvr_fp16mul_s3 = 128'h0;
573        1/1              dvr_fp16mul_s4567 = 128'h0;
574        1/1              cru_fp16mul_s0123 = 2'b00;
575        1/1              cru_fp16mul_s4567 = 4'b0000;
576        1/1              cru_fp16mul = 3'b000;
577                         
578                         // 复位系统
579        1/1              reset_system();
580                         // 执行固定测试
581        1/1              fixed_test();
582                         // 执行无效指令测试
583        1/1              test_idle_instruction(16'h3c00, 16'h3c00, 0, 0);
584                         // 执行所有寄存器组组合测试
585        1/1              test_all_bank_combinations(16'h3c00, 16'h4000, 16'hbc00, 16'h4400, 0); 
586                         // 执行32组同时随机测试
587        1/1              test_32groups_simultaneous_random(5); 
588                         // 执行随机测试
589        1/1              random_test(random_num);
590                         
591                         // 等待所有操作完成
592        3/3              repeat (5) @(posedge clk);
                        REPEAT_FALSE
593                         
594                         // 显示测试总结
595        1/1              $display("=== 测试完成 ===");
596        1/1              $display("总测试数: %0d", test_count);
597        1/1              $display("通过: %0d", pass_count);
598        1/1              $display("失败: %0d", fail_count);
599        1/1              if (test_count > 0)
600        1/1                  $display("通过率: %0.1f%%", (pass_count * 100.0) / test_count);
                   ==>  MISSING_ELSE
601                         
602        1/1              if (fail_count == 0) begin
603        1/1                $display("*** 所有测试通过! ***");
604                         end else begin
605        0/1     ==>        $display("*** 有测试失败! ***");
606                         end
607                         
608        1/1              $finish;

-------------------------------------------------------------------------------
Toggle Coverage for Module : tb_fp16_to_fp32_multiplier
                Total Covered Percent 
Totals          18    5       27.78   
Total Bits      3350  3109    92.81   
Total Bits 0->1 1675  1555    92.84   
Total Bits 1->0 1675  1554    92.78   

                                  
Signals          18   5    27.78  
Signal Bits      3350 3109 92.81  
Signal Bits 0->1 1675 1555 92.84  
Signal Bits 1->0 1675 1554 92.78  

Signal Details
                         Toggle Toggle 1->0 Toggle 0->1 
clk                      Yes    Yes         Yes         
rst_n                    No     No          Yes         
dvr_fp16mul_s0[47:0]     Yes    Yes         Yes         
dvr_fp16mul_s0[48]       No     No          No          
dvr_fp16mul_s0[127:49]   Yes    Yes         Yes         
dvr_fp16mul_s1[32:0]     Yes    Yes         Yes         
dvr_fp16mul_s1[33]       No     No          No          
dvr_fp16mul_s1[77:34]    Yes    Yes         Yes         
dvr_fp16mul_s1[78]       No     No          No          
dvr_fp16mul_s1[84:79]    Yes    Yes         Yes         
dvr_fp16mul_s1[85]       No     No          No          
dvr_fp16mul_s1[127:86]   Yes    Yes         Yes         
dvr_fp16mul_s2[89:0]     Yes    Yes         Yes         
dvr_fp16mul_s2[90]       No     No          No          
dvr_fp16mul_s2[122:91]   Yes    Yes         Yes         
dvr_fp16mul_s2[123]      No     No          No          
dvr_fp16mul_s2[127:124]  Yes    Yes         Yes         
dvr_fp16mul_s3[56:0]     Yes    Yes         Yes         
dvr_fp16mul_s3[57]       No     No          No          
dvr_fp16mul_s3[84:58]    Yes    Yes         Yes         
dvr_fp16mul_s3[85]       No     No          No          
dvr_fp16mul_s3[119:86]   Yes    Yes         Yes         
dvr_fp16mul_s3[120]      No     No          No          
dvr_fp16mul_s3[124:121]  Yes    Yes         Yes         
dvr_fp16mul_s3[125]      No     No          No          
dvr_fp16mul_s3[127:126]  Yes    Yes         Yes         
dvr_fp16mul_s4567[127:0] Yes    Yes         Yes         
cru_fp16mul_s0123[1:0]   Yes    Yes         Yes         
cru_fp16mul_s4567[3:0]   Yes    Yes         Yes         
cru_fp16mul[2:0]         Yes    Yes         Yes         
dr_fp16mul_d0[1:0]       No     No          No          
dr_fp16mul_d0[3:2]       Yes    Yes         Yes         
dr_fp16mul_d0[5:4]       No     No          No          
dr_fp16mul_d0[7:6]       Yes    Yes         Yes         
dr_fp16mul_d0[9:8]       No     No          No          
dr_fp16mul_d0[11:10]     Yes    Yes         Yes         
dr_fp16mul_d0[13:12]     No     No          No          
dr_fp16mul_d0[15:14]     Yes    Yes         Yes         
dr_fp16mul_d0[17:16]     No     No          No          
dr_fp16mul_d0[18]        Yes    Yes         Yes         
dr_fp16mul_d0[22:19]     No     No          No          
dr_fp16mul_d0[23]        Yes    Yes         Yes         
dr_fp16mul_d0[25:24]     No     No          No          
dr_fp16mul_d0[27:26]     Yes    Yes         Yes         
dr_fp16mul_d0[30:28]     No     No          No          
dr_fp16mul_d0[31]        Yes    Yes         Yes         
dr_fp16mul_d0[33:32]     No     No          No          
dr_fp16mul_d0[35:34]     Yes    Yes         Yes         
dr_fp16mul_d0[37:36]     No     No          No          
dr_fp16mul_d0[39:38]     Yes    Yes         Yes         
dr_fp16mul_d0[41:40]     No     No          No          
dr_fp16mul_d0[43:42]     Yes    Yes         Yes         
dr_fp16mul_d0[45:44]     No     No          No          
dr_fp16mul_d0[46]        Yes    Yes         Yes         
dr_fp16mul_d0[53:47]     No     No          No          
dr_fp16mul_d0[55:54]     Yes    Yes         Yes         
dr_fp16mul_d0[57:56]     No     No          No          
dr_fp16mul_d0[59:58]     Yes    Yes         Yes         
dr_fp16mul_d0[61:60]     No     No          No          
dr_fp16mul_d0[63:62]     Yes    Yes         Yes         
dr_fp16mul_d0[65:64]     No     No          No          
dr_fp16mul_d0[67:66]     Yes    Yes         Yes         
dr_fp16mul_d0[73:68]     No     No          No          
dr_fp16mul_d0[75:74]     Yes    Yes         Yes         
dr_fp16mul_d0[78:76]     No     No          No          
dr_fp16mul_d0[79]        Yes    Yes         Yes         
dr_fp16mul_d0[81:80]     No     No          No          
dr_fp16mul_d0[83:82]     Yes    Yes         Yes         
dr_fp16mul_d0[85:84]     No     No          No          
dr_fp16mul_d0[86]        Yes    Yes         Yes         
dr_fp16mul_d0[89:87]     No     No          No          
dr_fp16mul_d0[91:90]     Yes    Yes         Yes         
dr_fp16mul_d0[93:92]     No     No          No          
dr_fp16mul_d0[95:94]     Yes    Yes         Yes         
dr_fp16mul_d0[98:96]     No     No          No          
dr_fp16mul_d0[99]        Yes    Yes         Yes         
dr_fp16mul_d0[101:100]   No     No          No          
dr_fp16mul_d0[103:102]   Yes    Yes         Yes         
dr_fp16mul_d0[105:104]   No     No          No          
dr_fp16mul_d0[107:106]   Yes    Yes         Yes         
dr_fp16mul_d0[109:108]   No     No          No          
dr_fp16mul_d0[110]       Yes    Yes         Yes         
dr_fp16mul_d0[113:111]   No     No          No          
dr_fp16mul_d0[115:114]   Yes    Yes         Yes         
dr_fp16mul_d0[118:116]   No     No          No          
dr_fp16mul_d0[119]       Yes    Yes         Yes         
dr_fp16mul_d0[121:120]   No     No          No          
dr_fp16mul_d0[123:122]   Yes    Yes         Yes         
dr_fp16mul_d0[125:124]   No     No          No          
dr_fp16mul_d0[127:126]   Yes    Yes         Yes         
dr_fp16mul_d1[35:0]      Yes    Yes         Yes         
dr_fp16mul_d1[36]        No     No          No          
dr_fp16mul_d1[42:37]     Yes    Yes         Yes         
dr_fp16mul_d1[43]        No     No          No          
dr_fp16mul_d1[58:44]     Yes    Yes         Yes         
dr_fp16mul_d1[59]        No     No          No          
dr_fp16mul_d1[62:60]     Yes    Yes         Yes         
dr_fp16mul_d1[63]        No     No          No          
dr_fp16mul_d1[65:64]     Yes    Yes         Yes         
dr_fp16mul_d1[66]        No     No          No          
dr_fp16mul_d1[103:67]    Yes    Yes         Yes         
dr_fp16mul_d1[104]       No     No          No          
dr_fp16mul_d1[118:105]   Yes    Yes         Yes         
dr_fp16mul_d1[119]       No     No          No          
dr_fp16mul_d1[127:120]   Yes    Yes         Yes         
dr_fp16mul_d2[63:0]      Yes    Yes         Yes         
dr_fp16mul_d2[64]        No     No          No          
dr_fp16mul_d2[91:65]     Yes    Yes         Yes         
dr_fp16mul_d2[92]        No     No          No          
dr_fp16mul_d2[93]        Yes    Yes         Yes         
dr_fp16mul_d2[94]        No     No          No          
dr_fp16mul_d2[125:95]    Yes    Yes         Yes         
dr_fp16mul_d2[126]       No     No          No          
dr_fp16mul_d2[127]       Yes    Yes         Yes         
dr_fp16mul_d3[23:0]      Yes    Yes         Yes         
dr_fp16mul_d3[24]        No     No          No          
dr_fp16mul_d3[40:25]     Yes    Yes         Yes         
dr_fp16mul_d3[41]        No     No          No          
dr_fp16mul_d3[57:42]     Yes    Yes         Yes         
dr_fp16mul_d3[58]        No     No          No          
dr_fp16mul_d3[60:59]     Yes    Yes         Yes         
dr_fp16mul_d3[61]        No     No          No          
dr_fp16mul_d3[66:62]     Yes    Yes         Yes         
dr_fp16mul_d3[67]        No     No          No          
dr_fp16mul_d3[125:68]    Yes    Yes         Yes         
dr_fp16mul_d3[126]       No     No          No          
dr_fp16mul_d3[127]       Yes    Yes         Yes         
dr_fp16mul_d4[44:0]      Yes    Yes         Yes         
dr_fp16mul_d4[45]        No     No          No          
dr_fp16mul_d4[75:46]     Yes    Yes         Yes         
dr_fp16mul_d4[76]        No     No          No          
dr_fp16mul_d4[80:77]     Yes    Yes         Yes         
dr_fp16mul_d4[81]        No     No          No          
dr_fp16mul_d4[102:82]    Yes    Yes         Yes         
dr_fp16mul_d4[103]       No     No          No          
dr_fp16mul_d4[125:104]   Yes    Yes         Yes         
dr_fp16mul_d4[126]       No     No          No          
dr_fp16mul_d4[127]       Yes    Yes         Yes         
dr_fp16mul_d5[23:0]      Yes    Yes         Yes         
dr_fp16mul_d5[24]        No     No          No          
dr_fp16mul_d5[43:25]     Yes    Yes         Yes         
dr_fp16mul_d5[44]        No     No          No          
dr_fp16mul_d5[49:45]     Yes    Yes         Yes         
dr_fp16mul_d5[50]        No     No          No          
dr_fp16mul_d5[72:51]     Yes    Yes         Yes         
dr_fp16mul_d5[73]        No     No          No          
dr_fp16mul_d5[90:74]     Yes    Yes         Yes         
dr_fp16mul_d5[91]        No     No          No          
dr_fp16mul_d5[95:92]     Yes    Yes         Yes         
dr_fp16mul_d5[96]        No     No          No          
dr_fp16mul_d5[111:97]    Yes    Yes         Yes         
dr_fp16mul_d5[112]       No     No          No          
dr_fp16mul_d5[113]       Yes    Yes         Yes         
dr_fp16mul_d5[114]       No     No          No          
dr_fp16mul_d5[127:115]   Yes    Yes         Yes         
dr_fp16mul_d6[65:0]      Yes    Yes         Yes         
dr_fp16mul_d6[66]        No     No          No          
dr_fp16mul_d6[127:67]    Yes    Yes         Yes         
dr_fp16mul_d7[47:0]      Yes    Yes         Yes         
dr_fp16mul_d7[49:48]     No     No          No          
dr_fp16mul_d7[127:50]    Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : tb_fp16_to_fp32_multiplier
         Line No. Total Covered Percent 
Branches          4     2       50.00   
IF       599      2     1       50.00   
IF       602      2     1       50.00   


599            if (test_count > 0)
               -1-  
600                $display("通过率: %0.1f%%", (pass_count * 100.0) / test_count);
                   ==>
                   MISSING_ELSE
                   ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


602            if (fail_count == 0) begin
               -1-  
603              $display("*** 所有测试通过! ***");
                 ==>
604            end else begin
605              $display("*** 有测试失败! ***");
                 ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_fp16_to_fp32_multiplier
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 79.21  94.82 --      92.81 --      50.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 91.16  95.76 --      94.40 --      83.33 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                       
 79.21  94.82 --      92.81 --      50.00 tb_fp16_to_fp32_multiplier 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME 
 95.43  98.33 --      95.11 --      92.86 uut  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : fp16_to_fp32_multiplier
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 95.43  98.33 --      95.11 --      92.86 

Source File(s) : 

/home/Sunny/SMC/03_fp16_to_fp32_multiplier/fp16_to_fp32_multiplier.v

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                           
 95.43  98.33 --      95.11 --      92.86 tb_fp16_to_fp32_multiplier.uut 



-------------------------------------------------------------------------------
Line Coverage for Module : fp16_to_fp32_multiplier

             Line No.   Total   Covered  Percent
TOTAL                      120      118    98.33
ALWAYS             64       20       20   100.00
ROUTINE           142       54       52    96.30
ROUTINE           249        6        6   100.00
ALWAYS            263       40       40   100.00

63                      always @(posedge clk or negedge rst_n) begin
64         1/1              if (!rst_n) begin
65         4/4                  selected_s0_r <= 128'b0; selected_s1_r <= 128'b0; selected_s2_r <= 128'b0; selected_s3_r <= 128'b0;
66         4/4                  selected_s4_r <= 128'b0; selected_s5_r <= 128'b0; selected_s6_r <= 128'b0; selected_s7_r <= 128'b0;
67         1/1                  compute_valid_r <= 1'b0;
68                          end else begin
69                              // 当本拍收到有效乘法指令时，锁存所选 bank 的数据，结果在下一拍写回
70         1/1                  if (cru_valid) begin
71         1/1                      selected_s0_r <= dr_s0[cru_s0_sel];
72         1/1                      selected_s1_r <= dr_s1[cru_s0_sel];
73         1/1                      selected_s2_r <= dr_s2[cru_s0_sel];
74         1/1                      selected_s3_r <= dr_s3[cru_s0_sel];
75         1/1                      selected_s4_r <= dr_s4[cru_s1_sel];
76         1/1                      selected_s5_r <= dr_s5[cru_s1_sel];
77         1/1                      selected_s6_r <= dr_s6[cru_s1_sel];
78         1/1                      selected_s7_r <= dr_s7[cru_s1_sel];
79                              end
                        MISSING_ELSE
80         1/1                  compute_valid_r <= cru_valid; // 延迟一拍
81                          end
82                      end
83                      
84                      // 32个fp16乘法器的输出结果
85                      wire [31:0] fp32_results [0:PARAM_DR_FP16MUL_CNT-1];
86                      
87                      // 生成32个fp16乘法器实例
88                      genvar i;
89                      generate
90                          for (i = 0; i < PARAM_DR_FP16MUL_CNT; i = i + 1) begin : fp16_multipliers
91                              wire [15:0] fp16_a = {selected_s3_r[i*4 +: 4], selected_s2_r[i*4 +: 4], 
92                                                    selected_s1_r[i*4 +: 4], selected_s0_r[i*4 +: 4]};
93                              wire [15:0] fp16_b = {selected_s7_r[i*4 +: 4], selected_s6_r[i*4 +: 4], 
94                                                    selected_s5_r[i*4 +: 4], selected_s4_r[i*4 +: 4]};
95                              assign fp32_results[i] = fp16_mul(fp16_a, fp16_b);
96                          end
97                      endgenerate
98                      
99                      // fp16乘法器
100                     function [31:0] fp16_mul;
101                         input [15:0] a;        
102                         input [15:0] b;        
103                         
104                         // 内部变量
105                         reg a_sign, b_sign, result_sign;
106                         reg [4:0] a_exp, b_exp;
107                         reg [9:0] a_mant, b_mant;
108                         
109                         reg a_zero, b_zero;
110                         reg a_inf, b_inf;
111                         reg a_nan, b_nan;
112                         reg a_denorm, b_denorm;
113                         
114                         reg result_nan, result_inf, result_zero;
115                         
116                         reg [10:0] a_mant_full, b_mant_full;  // 带隐藏位的尾数
117                         reg [21:0] mant_product;              // 尾数乘积
118                         reg product_has_overflow;             // 乘积是否溢出
119                         reg need_denormalize;                 // 需要处理非规格化数
120                         reg [4:0] leading_zeros;              // 前导零数量
121                         reg [21:0] normalized_mant;           // 规格化后的尾数
122                         reg [22:0] final_mantissa;            // 最终尾数
123                         
124                         reg [7:0] a_exp_adj, b_exp_adj;       // 调整后的指数
125                         reg [9:0] result_exp_unbiased;        // 无偏结果指数
126                         reg [9:0] exp_adjust;                 // 指数调整值
127                         reg [7:0] result_exp_biased;          // 有偏结果指数
128                         
129                         reg [22:0] out_mant;                  // 输出尾数
130                         reg [7:0] out_exp;                    // 输出指数
131                         
132                         // 常量定义
133                         localparam FP16_BIAS = 15;
134                         localparam FP32_BIAS = 127;
135                         localparam FP16_MANT_BITS = 10;
136                         localparam FP32_MANT_BITS = 23;
137                         localparam FP16_EXP_BITS = 5;
138                         localparam FP32_EXP_BITS = 8;
139                         
140                         begin
141                             // 提取输入操作数的各个字段
142        1/1                  a_sign = a[15];
143        1/1                  b_sign = b[15];
144        1/1                  a_exp = a[14:10];
145        1/1                  b_exp = b[14:10];
146        1/1                  a_mant = a[9:0];
147        1/1                  b_mant = b[9:0];
148                     
149                             // 检查特殊输入值
150        1/1                  a_zero = (a_exp == 0) && (a_mant == 0);
151        1/1                  b_zero = (b_exp == 0) && (b_mant == 0);
152                     
153        1/1                  a_inf = (a_exp == 5'b11111) && (a_mant == 0);
154        1/1                  b_inf = (b_exp == 5'b11111) && (b_mant == 0);
155                             
156        1/1                  a_nan = (a_exp == 5'b11111) && (a_mant != 0);
157        1/1                  b_nan = (b_exp == 5'b11111) && (b_mant != 0);
158                             
159        1/1                  a_denorm = (a_exp == 0) && (a_mant != 0);
160        1/1                  b_denorm = (b_exp == 0) && (b_mant != 0);
161                             
162        1/1                  result_nan = a_nan || b_nan || (a_inf && b_zero) || (a_zero && b_inf);
163        1/1                  result_inf = (a_inf || b_inf) && !result_nan;
164        1/1                  result_zero = (a_zero || b_zero) && !result_nan && !result_inf;
165                             
166                             // 计算结果的符号位
167        1/1                  result_sign = a_sign ^ b_sign;
168                             
169                             // 处理尾数的隐藏位
170        1/1                  a_mant_full = a_denorm ? {1'b0, a_mant} : {1'b1, a_mant};
171        1/1                  b_mant_full = b_denorm ? {1'b0, b_mant} : {1'b1, b_mant};
172                     
173                             // 计算尾数乘积
174        1/1                  mant_product = a_mant_full * b_mant_full;
175                             
176                             // 检查乘积是否溢出（最高位是否为1）
177        1/1                  product_has_overflow = mant_product[21];
178                             
179                             // 确定是否需要非规格化处理
180        1/1                  need_denormalize = a_denorm || b_denorm;
181                             
182                             // 计算前导零数量
183        1/1                  leading_zeros = count_leading_zeros(mant_product);
184                             
185                             // 规格化尾数
186        1/1                  if (mant_product == 0) begin
187        0/1     ==>              normalized_mant = 22'b0;
188        1/1                  end else if (need_denormalize) begin
189        1/1                      normalized_mant = mant_product << leading_zeros;
190                             end else begin
191        1/1                      normalized_mant = product_has_overflow ? (mant_product >> 1) : mant_product;
192                             end
193                             
194                             // 确定最终尾数值（不储存隐藏位）
195        1/1                  if (mant_product == 0) begin
196        0/1     ==>              final_mantissa = 0;
197        1/1                  end else if (need_denormalize) begin
198        1/1                      final_mantissa = {normalized_mant[20:0], 2'b00};
199        1/1                  end else if (product_has_overflow) begin
200        1/1                      final_mantissa = {mant_product[20:0], 2'b00};
201                             end else begin
202        1/1                      final_mantissa = {mant_product[19:0], 3'b00};
203                             end
204                             
205                             // 计算无偏指数
206        1/1                  a_exp_adj = a_denorm ? -14 : a_exp - FP16_BIAS;
207        1/1                  b_exp_adj = b_denorm ? -14 : b_exp - FP16_BIAS;
208        1/1                  result_exp_unbiased = a_exp_adj + b_exp_adj;
209                             
210                             // 计算指数调整值
211        1/1                  if (need_denormalize) begin
212        1/1                      exp_adjust = (mant_product == 0) ? 0 : -leading_zeros + normalized_mant[21];
213                             end else begin
214        1/1                      exp_adjust = product_has_overflow ? 1 : 0;
215                             end
216                             
217                             // 计算有偏指数
218        1/1                  result_exp_biased = result_exp_unbiased + exp_adjust + FP32_BIAS;
219                      
220                             // 确定输出尾数
221        1/1                  if (result_zero) begin
222        1/1                      out_mant = 0;
223        1/1                  end else if (result_inf || result_nan) begin
224        1/1                      out_mant = result_nan ? {1'b1, {22{1'b0}}} : 0;
225                             end else begin
226        1/1                      out_mant = final_mantissa;
227                             end
228                             
229                             // 确定输出指数
230        1/1                  if (result_zero) begin
231        1/1                      out_exp = 0;
232        1/1                  end else if (result_inf || result_nan) begin
233        1/1                      out_exp = 8'hFF;
234                             end else begin
235        1/1                      out_exp = result_exp_biased;
236                             end
237                             
238                             // 组合最终结果
239        1/1                  fp16_mul = {result_sign, out_exp, out_mant};
240                         end
241                     endfunction
242                     
243                     // 计算前导零的函数 
244                     function automatic [4:0] count_leading_zeros;
245                         input [21:0] value;
246                         reg [4:0] count;
247                         reg [21:0] temp;
248                         begin
249        1/1                  count = 0;
250        1/1                  temp = value;
251                             
252        1/1                  while (count < 21 && temp[21] == 1'b0 && temp != 0) begin
253        1/1                      count = count + 1;
254        1/1                      temp = temp << 1;
255                             end
                   ==>  WHILE_FALSE
256        1/1                  count_leading_zeros = count;
257                         end
258                     endfunction 
259                     
260                     integer j, k;  
261                     
262                     always @(posedge clk or negedge rst_n) begin
263        1/1              if (!rst_n) begin
264                             // 复位所有寄存器
265        1/1                  for (j = 0; j < PARAM_DR_FP16MUL_S0_CNT; j = j + 1) begin
266        1/1                      dr_s0[j] <= 128'b0;
267        1/1                      dr_s1[j] <= 128'b0;
268        1/1                      dr_s2[j] <= 128'b0;
269        1/1                      dr_s3[j] <= 128'b0;
270                             end
271        1/1                  for (j = 0; j < PARAM_DR_FP16MUL_S1_CNT; j = j + 1) begin
272        1/1                      dr_s4[j] <= 128'b0;
273        1/1                      dr_s5[j] <= 128'b0;
274        1/1                      dr_s6[j] <= 128'b0;
275        1/1                      dr_s7[j] <= 128'b0;
276                             end
277        1/1                  dr_fp16mul_d0 <= 128'b0;
278        1/1                  dr_fp16mul_d1 <= 128'b0;
279        1/1                  dr_fp16mul_d2 <= 128'b0;
280        1/1                  dr_fp16mul_d3 <= 128'b0;
281        1/1                  dr_fp16mul_d4 <= 128'b0;
282        1/1                  dr_fp16mul_d5 <= 128'b0;
283        1/1                  dr_fp16mul_d6 <= 128'b0;
284        1/1                  dr_fp16mul_d7 <= 128'b0;
285                         end else begin
286                             // s0123更新逻辑
287        1/1                  if (cru_s0123_valid) begin
288        1/1                      dr_s0[cru_s0123_reg_sel] <= dvr_fp16mul_s0;
289        1/1                      dr_s1[cru_s0123_reg_sel] <= dvr_fp16mul_s1;
290        1/1                      dr_s2[cru_s0123_reg_sel] <= dvr_fp16mul_s2;
291        1/1                      dr_s3[cru_s0123_reg_sel] <= dvr_fp16mul_s3;
292                             end
                        MISSING_ELSE
293                             
294                             // s4567更新逻辑
295        1/1                  if (cru_s4567_valid) begin
296        1/1                      case (cru_s4567_low)
297        1/1                          2'b00: dr_s4[cru_s4567_high] <= dvr_fp16mul_s4567;
298        1/1                          2'b01: dr_s5[cru_s4567_high] <= dvr_fp16mul_s4567;
299        1/1                          2'b10: dr_s6[cru_s4567_high] <= dvr_fp16mul_s4567;
300        1/1                          2'b11: dr_s7[cru_s4567_high] <= dvr_fp16mul_s4567;
                   ==>  MISSING_DEFAULT
301                                 endcase
302                             end
                        MISSING_ELSE
303                             
304                             // 结果写回延迟一拍，保证源选择锁存后再计算
305        1/1                  if (compute_valid_r) begin
306        1/1                      for (k = 0; k < PARAM_DR_FP16MUL_CNT; k = k + 1) begin
307        1/1                          dr_fp16mul_d0[k*4 +: 4] <= fp32_results[k][3:0];
308        1/1                          dr_fp16mul_d1[k*4 +: 4] <= fp32_results[k][7:4];
309        1/1                          dr_fp16mul_d2[k*4 +: 4] <= fp32_results[k][11:8];
310        1/1                          dr_fp16mul_d3[k*4 +: 4] <= fp32_results[k][15:12];
311        1/1                          dr_fp16mul_d4[k*4 +: 4] <= fp32_results[k][19:16];
312        1/1                          dr_fp16mul_d5[k*4 +: 4] <= fp32_results[k][23:20];
313        1/1                          dr_fp16mul_d6[k*4 +: 4] <= fp32_results[k][27:24];
314        1/1                          dr_fp16mul_d7[k*4 +: 4] <= fp32_results[k][31:28];
315                                 end
316                             end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : fp16_to_fp32_multiplier
                Total Covered Percent 
Totals          99    54      54.55   
Total Bits      7466  7101    95.11   
Total Bits 0->1 3733  3551    95.12   
Total Bits 1->0 3733  3550    95.10   

                                
Ports          18   5    27.78  
Port Bits      3350 3109 92.81  
Port Bits 0->1 1675 1555 92.84  
Port Bits 1->0 1675 1554 92.78  

                                  
Signals          81   49   60.49  
Signal Bits      4116 3992 96.99  
Signal Bits 0->1 2058 1996 96.99  
Signal Bits 1->0 2058 1996 96.99  

Port Details
                         Toggle Toggle 1->0 Toggle 0->1 Direction 
clk                      Yes    Yes         Yes         INPUT     
rst_n                    No     No          Yes         INPUT     
dvr_fp16mul_s0[47:0]     Yes    Yes         Yes         INPUT     
dvr_fp16mul_s0[48]       No     No          No          INPUT     
dvr_fp16mul_s0[127:49]   Yes    Yes         Yes         INPUT     
dvr_fp16mul_s1[32:0]     Yes    Yes         Yes         INPUT     
dvr_fp16mul_s1[33]       No     No          No          INPUT     
dvr_fp16mul_s1[77:34]    Yes    Yes         Yes         INPUT     
dvr_fp16mul_s1[78]       No     No          No          INPUT     
dvr_fp16mul_s1[84:79]    Yes    Yes         Yes         INPUT     
dvr_fp16mul_s1[85]       No     No          No          INPUT     
dvr_fp16mul_s1[127:86]   Yes    Yes         Yes         INPUT     
dvr_fp16mul_s2[89:0]     Yes    Yes         Yes         INPUT     
dvr_fp16mul_s2[90]       No     No          No          INPUT     
dvr_fp16mul_s2[122:91]   Yes    Yes         Yes         INPUT     
dvr_fp16mul_s2[123]      No     No          No          INPUT     
dvr_fp16mul_s2[127:124]  Yes    Yes         Yes         INPUT     
dvr_fp16mul_s3[56:0]     Yes    Yes         Yes         INPUT     
dvr_fp16mul_s3[57]       No     No          No          INPUT     
dvr_fp16mul_s3[84:58]    Yes    Yes         Yes         INPUT     
dvr_fp16mul_s3[85]       No     No          No          INPUT     
dvr_fp16mul_s3[119:86]   Yes    Yes         Yes         INPUT     
dvr_fp16mul_s3[120]      No     No          No          INPUT     
dvr_fp16mul_s3[124:121]  Yes    Yes         Yes         INPUT     
dvr_fp16mul_s3[125]      No     No          No          INPUT     
dvr_fp16mul_s3[127:126]  Yes    Yes         Yes         INPUT     
dvr_fp16mul_s4567[127:0] Yes    Yes         Yes         INPUT     
dr_fp16mul_d0[1:0]       No     No          No          OUTPUT    
dr_fp16mul_d0[3:2]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[5:4]       No     No          No          OUTPUT    
dr_fp16mul_d0[7:6]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[9:8]       No     No          No          OUTPUT    
dr_fp16mul_d0[11:10]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[13:12]     No     No          No          OUTPUT    
dr_fp16mul_d0[15:14]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[17:16]     No     No          No          OUTPUT    
dr_fp16mul_d0[18]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[22:19]     No     No          No          OUTPUT    
dr_fp16mul_d0[23]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[25:24]     No     No          No          OUTPUT    
dr_fp16mul_d0[27:26]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[30:28]     No     No          No          OUTPUT    
dr_fp16mul_d0[31]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[33:32]     No     No          No          OUTPUT    
dr_fp16mul_d0[35:34]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[37:36]     No     No          No          OUTPUT    
dr_fp16mul_d0[39:38]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[41:40]     No     No          No          OUTPUT    
dr_fp16mul_d0[43:42]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[45:44]     No     No          No          OUTPUT    
dr_fp16mul_d0[46]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[53:47]     No     No          No          OUTPUT    
dr_fp16mul_d0[55:54]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[57:56]     No     No          No          OUTPUT    
dr_fp16mul_d0[59:58]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[61:60]     No     No          No          OUTPUT    
dr_fp16mul_d0[63:62]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[65:64]     No     No          No          OUTPUT    
dr_fp16mul_d0[67:66]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[73:68]     No     No          No          OUTPUT    
dr_fp16mul_d0[75:74]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[78:76]     No     No          No          OUTPUT    
dr_fp16mul_d0[79]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[81:80]     No     No          No          OUTPUT    
dr_fp16mul_d0[83:82]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[85:84]     No     No          No          OUTPUT    
dr_fp16mul_d0[86]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[89:87]     No     No          No          OUTPUT    
dr_fp16mul_d0[91:90]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[93:92]     No     No          No          OUTPUT    
dr_fp16mul_d0[95:94]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[98:96]     No     No          No          OUTPUT    
dr_fp16mul_d0[99]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[101:100]   No     No          No          OUTPUT    
dr_fp16mul_d0[103:102]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[105:104]   No     No          No          OUTPUT    
dr_fp16mul_d0[107:106]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[109:108]   No     No          No          OUTPUT    
dr_fp16mul_d0[110]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[113:111]   No     No          No          OUTPUT    
dr_fp16mul_d0[115:114]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[118:116]   No     No          No          OUTPUT    
dr_fp16mul_d0[119]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[121:120]   No     No          No          OUTPUT    
dr_fp16mul_d0[123:122]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d0[125:124]   No     No          No          OUTPUT    
dr_fp16mul_d0[127:126]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[35:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[36]        No     No          No          OUTPUT    
dr_fp16mul_d1[42:37]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[43]        No     No          No          OUTPUT    
dr_fp16mul_d1[58:44]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[59]        No     No          No          OUTPUT    
dr_fp16mul_d1[62:60]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[63]        No     No          No          OUTPUT    
dr_fp16mul_d1[65:64]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[66]        No     No          No          OUTPUT    
dr_fp16mul_d1[103:67]    Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[104]       No     No          No          OUTPUT    
dr_fp16mul_d1[118:105]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d1[119]       No     No          No          OUTPUT    
dr_fp16mul_d1[127:120]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d2[63:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d2[64]        No     No          No          OUTPUT    
dr_fp16mul_d2[91:65]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d2[92]        No     No          No          OUTPUT    
dr_fp16mul_d2[93]        Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d2[94]        No     No          No          OUTPUT    
dr_fp16mul_d2[125:95]    Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d2[126]       No     No          No          OUTPUT    
dr_fp16mul_d2[127]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[23:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[24]        No     No          No          OUTPUT    
dr_fp16mul_d3[40:25]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[41]        No     No          No          OUTPUT    
dr_fp16mul_d3[57:42]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[58]        No     No          No          OUTPUT    
dr_fp16mul_d3[60:59]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[61]        No     No          No          OUTPUT    
dr_fp16mul_d3[66:62]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[67]        No     No          No          OUTPUT    
dr_fp16mul_d3[125:68]    Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d3[126]       No     No          No          OUTPUT    
dr_fp16mul_d3[127]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d4[44:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d4[45]        No     No          No          OUTPUT    
dr_fp16mul_d4[75:46]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d4[76]        No     No          No          OUTPUT    
dr_fp16mul_d4[80:77]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d4[81]        No     No          No          OUTPUT    
dr_fp16mul_d4[102:82]    Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d4[103]       No     No          No          OUTPUT    
dr_fp16mul_d4[125:104]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d4[126]       No     No          No          OUTPUT    
dr_fp16mul_d4[127]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[23:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[24]        No     No          No          OUTPUT    
dr_fp16mul_d5[43:25]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[44]        No     No          No          OUTPUT    
dr_fp16mul_d5[49:45]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[50]        No     No          No          OUTPUT    
dr_fp16mul_d5[72:51]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[73]        No     No          No          OUTPUT    
dr_fp16mul_d5[90:74]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[91]        No     No          No          OUTPUT    
dr_fp16mul_d5[95:92]     Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[96]        No     No          No          OUTPUT    
dr_fp16mul_d5[111:97]    Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[112]       No     No          No          OUTPUT    
dr_fp16mul_d5[113]       Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d5[114]       No     No          No          OUTPUT    
dr_fp16mul_d5[127:115]   Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d6[65:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d6[66]        No     No          No          OUTPUT    
dr_fp16mul_d6[127:67]    Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d7[47:0]      Yes    Yes         Yes         OUTPUT    
dr_fp16mul_d7[49:48]     No     No          No          OUTPUT    
dr_fp16mul_d7[127:50]    Yes    Yes         Yes         OUTPUT    
cru_fp16mul_s0123[1:0]   Yes    Yes         Yes         INPUT     
cru_fp16mul_s4567[3:0]   Yes    Yes         Yes         INPUT     
cru_fp16mul[2:0]         Yes    Yes         Yes         INPUT     

Signal Details
                                   Toggle Toggle 1->0 Toggle 0->1 
cru_valid                          Yes    Yes         Yes         
cru_s0_sel                         Yes    Yes         Yes         
cru_s1_sel                         Yes    Yes         Yes         
cru_s0123_valid                    Yes    Yes         Yes         
cru_s0123_reg_sel                  Yes    Yes         Yes         
cru_s4567_valid                    Yes    Yes         Yes         
cru_s4567_high                     Yes    Yes         Yes         
cru_s4567_low[1:0]                 Yes    Yes         Yes         
selected_s0_r[47:0]                Yes    Yes         Yes         
selected_s0_r[48]                  No     No          No          
selected_s0_r[127:49]              Yes    Yes         Yes         
selected_s1_r[32:0]                Yes    Yes         Yes         
selected_s1_r[33]                  No     No          No          
selected_s1_r[77:34]               Yes    Yes         Yes         
selected_s1_r[78]                  No     No          No          
selected_s1_r[84:79]               Yes    Yes         Yes         
selected_s1_r[85]                  No     No          No          
selected_s1_r[127:86]              Yes    Yes         Yes         
selected_s2_r[89:0]                Yes    Yes         Yes         
selected_s2_r[90]                  No     No          No          
selected_s2_r[122:91]              Yes    Yes         Yes         
selected_s2_r[123]                 No     No          No          
selected_s2_r[127:124]             Yes    Yes         Yes         
selected_s3_r[56:0]                Yes    Yes         Yes         
selected_s3_r[57]                  No     No          No          
selected_s3_r[84:58]               Yes    Yes         Yes         
selected_s3_r[85]                  No     No          No          
selected_s3_r[119:86]              Yes    Yes         Yes         
selected_s3_r[120]                 No     No          No          
selected_s3_r[124:121]             Yes    Yes         Yes         
selected_s3_r[125]                 No     No          No          
selected_s3_r[127:126]             Yes    Yes         Yes         
selected_s4_r[13:0]                Yes    Yes         Yes         
selected_s4_r[14]                  No     No          No          
selected_s4_r[33:15]               Yes    Yes         Yes         
selected_s4_r[34]                  No     No          No          
selected_s4_r[61:35]               Yes    Yes         Yes         
selected_s4_r[62]                  No     No          No          
selected_s4_r[65:63]               Yes    Yes         Yes         
selected_s4_r[66]                  No     No          No          
selected_s4_r[105:67]              Yes    Yes         Yes         
selected_s4_r[106]                 No     No          No          
selected_s4_r[127:107]             Yes    Yes         Yes         
selected_s5_r[16:0]                Yes    Yes         Yes         
selected_s5_r[17]                  No     No          No          
selected_s5_r[18]                  Yes    Yes         Yes         
selected_s5_r[19]                  No     No          No          
selected_s5_r[21:20]               Yes    Yes         Yes         
selected_s5_r[22]                  No     No          No          
selected_s5_r[97:23]               Yes    Yes         Yes         
selected_s5_r[98]                  No     No          No          
selected_s5_r[127:99]              Yes    Yes         Yes         
selected_s6_r[20:0]                Yes    Yes         Yes         
selected_s6_r[21]                  No     No          No          
selected_s6_r[27:22]               Yes    Yes         Yes         
selected_s6_r[29:28]               No     No          No          
selected_s6_r[35:30]               Yes    Yes         Yes         
selected_s6_r[36]                  No     No          No          
selected_s6_r[62:37]               Yes    Yes         Yes         
selected_s6_r[63]                  No     No          No          
selected_s6_r[94:64]               Yes    Yes         Yes         
selected_s6_r[95]                  No     No          No          
selected_s6_r[100:96]              Yes    Yes         Yes         
selected_s6_r[101]                 No     No          No          
selected_s6_r[109:102]             Yes    Yes         Yes         
selected_s6_r[110]                 No     No          No          
selected_s6_r[127:111]             Yes    Yes         Yes         
selected_s7_r[47:0]                Yes    Yes         Yes         
selected_s7_r[48]                  No     No          No          
selected_s7_r[59:49]               Yes    Yes         Yes         
selected_s7_r[60]                  No     No          No          
selected_s7_r[117:61]              Yes    Yes         Yes         
selected_s7_r[118]                 No     No          No          
selected_s7_r[120:119]             Yes    Yes         Yes         
selected_s7_r[121]                 No     No          No          
selected_s7_r[127:122]             Yes    Yes         Yes         
compute_valid_r                    Yes    Yes         Yes         
fp16_multipliers[0].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[0].fp16_b[15:0]   Yes    Yes         Yes         
fp16_multipliers[1].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[1].fp16_b[15:0]   Yes    Yes         Yes         
fp16_multipliers[2].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[2].fp16_b[15:0]   Yes    Yes         Yes         
fp16_multipliers[3].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[3].fp16_b[1:0]    Yes    Yes         Yes         
fp16_multipliers[3].fp16_b[2]      No     No          No          
fp16_multipliers[3].fp16_b[15:3]   Yes    Yes         Yes         
fp16_multipliers[4].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[4].fp16_b[4:0]    Yes    Yes         Yes         
fp16_multipliers[4].fp16_b[5]      No     No          No          
fp16_multipliers[4].fp16_b[6]      Yes    Yes         Yes         
fp16_multipliers[4].fp16_b[7]      No     No          No          
fp16_multipliers[4].fp16_b[15:8]   Yes    Yes         Yes         
fp16_multipliers[5].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[5].fp16_b[5:0]    Yes    Yes         Yes         
fp16_multipliers[5].fp16_b[6]      No     No          No          
fp16_multipliers[5].fp16_b[8:7]    Yes    Yes         Yes         
fp16_multipliers[5].fp16_b[9]      No     No          No          
fp16_multipliers[5].fp16_b[15:10]  Yes    Yes         Yes         
fp16_multipliers[6].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[6].fp16_b[15:0]   Yes    Yes         Yes         
fp16_multipliers[7].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[7].fp16_b[7:0]    Yes    Yes         Yes         
fp16_multipliers[7].fp16_b[9:8]    No     No          No          
fp16_multipliers[7].fp16_b[15:10]  Yes    Yes         Yes         
fp16_multipliers[8].fp16_a[4:0]    Yes    Yes         Yes         
fp16_multipliers[8].fp16_a[5]      No     No          No          
fp16_multipliers[8].fp16_a[15:6]   Yes    Yes         Yes         
fp16_multipliers[8].fp16_b[1:0]    Yes    Yes         Yes         
fp16_multipliers[8].fp16_b[2]      No     No          No          
fp16_multipliers[8].fp16_b[15:3]   Yes    Yes         Yes         
fp16_multipliers[9].fp16_a[15:0]   Yes    Yes         Yes         
fp16_multipliers[9].fp16_b[7:0]    Yes    Yes         Yes         
fp16_multipliers[9].fp16_b[8]      No     No          No          
fp16_multipliers[9].fp16_b[15:9]   Yes    Yes         Yes         
fp16_multipliers[10].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[10].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[11].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[11].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[12].fp16_a[0]     No     No          No          
fp16_multipliers[12].fp16_a[15:1]  Yes    Yes         Yes         
fp16_multipliers[12].fp16_b[11:0]  Yes    Yes         Yes         
fp16_multipliers[12].fp16_b[12]    No     No          No          
fp16_multipliers[12].fp16_b[15:13] Yes    Yes         Yes         
fp16_multipliers[13].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[13].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[14].fp16_a[12:0]  Yes    Yes         Yes         
fp16_multipliers[14].fp16_a[13]    No     No          No          
fp16_multipliers[14].fp16_a[15:14] Yes    Yes         Yes         
fp16_multipliers[14].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[15].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[15].fp16_b[1:0]   Yes    Yes         Yes         
fp16_multipliers[15].fp16_b[2]     No     No          No          
fp16_multipliers[15].fp16_b[10:3]  Yes    Yes         Yes         
fp16_multipliers[15].fp16_b[12:11] No     No          No          
fp16_multipliers[15].fp16_b[15:13] Yes    Yes         Yes         
fp16_multipliers[16].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[16].fp16_b[1:0]   Yes    Yes         Yes         
fp16_multipliers[16].fp16_b[2]     No     No          No          
fp16_multipliers[16].fp16_b[15:3]  Yes    Yes         Yes         
fp16_multipliers[17].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[17].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[18].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[18].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[19].fp16_a[5:0]   Yes    Yes         Yes         
fp16_multipliers[19].fp16_a[6]     No     No          No          
fp16_multipliers[19].fp16_a[15:7]  Yes    Yes         Yes         
fp16_multipliers[19].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[20].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[20].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[21].fp16_a[4:0]   Yes    Yes         Yes         
fp16_multipliers[21].fp16_a[5]     No     No          No          
fp16_multipliers[21].fp16_a[12:6]  Yes    Yes         Yes         
fp16_multipliers[21].fp16_a[13]    No     No          No          
fp16_multipliers[21].fp16_a[15:14] Yes    Yes         Yes         
fp16_multipliers[21].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[22].fp16_a[9:0]   Yes    Yes         Yes         
fp16_multipliers[22].fp16_a[10]    No     No          No          
fp16_multipliers[22].fp16_a[15:11] Yes    Yes         Yes         
fp16_multipliers[22].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[23].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[23].fp16_b[10:0]  Yes    Yes         Yes         
fp16_multipliers[23].fp16_b[11]    No     No          No          
fp16_multipliers[23].fp16_b[15:12] Yes    Yes         Yes         
fp16_multipliers[24].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[24].fp16_b[5:0]   Yes    Yes         Yes         
fp16_multipliers[24].fp16_b[6]     No     No          No          
fp16_multipliers[24].fp16_b[15:7]  Yes    Yes         Yes         
fp16_multipliers[25].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[25].fp16_b[8:0]   Yes    Yes         Yes         
fp16_multipliers[25].fp16_b[9]     No     No          No          
fp16_multipliers[25].fp16_b[15:10] Yes    Yes         Yes         
fp16_multipliers[26].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[26].fp16_b[1:0]   Yes    Yes         Yes         
fp16_multipliers[26].fp16_b[2]     No     No          No          
fp16_multipliers[26].fp16_b[15:3]  Yes    Yes         Yes         
fp16_multipliers[27].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[27].fp16_b[9:0]   Yes    Yes         Yes         
fp16_multipliers[27].fp16_b[10]    No     No          No          
fp16_multipliers[27].fp16_b[15:11] Yes    Yes         Yes         
fp16_multipliers[28].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[28].fp16_b[15:0]  Yes    Yes         Yes         
fp16_multipliers[29].fp16_a[15:0]  Yes    Yes         Yes         
fp16_multipliers[29].fp16_b[13:0]  Yes    Yes         Yes         
fp16_multipliers[29].fp16_b[14]    No     No          No          
fp16_multipliers[29].fp16_b[15]    Yes    Yes         Yes         
fp16_multipliers[30].fp16_a[10:0]  Yes    Yes         Yes         
fp16_multipliers[30].fp16_a[12:11] No     No          No          
fp16_multipliers[30].fp16_a[15:13] Yes    Yes         Yes         
fp16_multipliers[30].fp16_b[12:0]  Yes    Yes         Yes         
fp16_multipliers[30].fp16_b[13]    No     No          No          
fp16_multipliers[30].fp16_b[15:14] Yes    Yes         Yes         
fp16_multipliers[31].fp16_a[12:0]  Yes    Yes         Yes         
fp16_multipliers[31].fp16_a[13]    No     No          No          
fp16_multipliers[31].fp16_a[15:14] Yes    Yes         Yes         
fp16_multipliers[31].fp16_b[15:0]  Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : fp16_to_fp32_multiplier
         Line No. Total Covered Percent 
Branches          14    13      92.86   
IF       64       3     3       100.00  
IF       263      11    10      90.91   


64             if (!rst_n) begin
               -1-  
65                 selected_s0_r <= 128'b0; selected_s1_r <= 128'b0; selected_s2_r <= 128'b0; selected_s3_r <= 128'b0;
                   ==>
66                 selected_s4_r <= 128'b0; selected_s5_r <= 128'b0; selected_s6_r <= 128'b0; selected_s7_r <= 128'b0;
67                 compute_valid_r <= 1'b0;
68             end else begin
69                 // 当本拍收到有效乘法指令时，锁存所选 bank 的数据，结果在下一拍写回
70                 if (cru_valid) begin
                   -2-  
71                     selected_s0_r <= dr_s0[cru_s0_sel];
                       ==>
72                     selected_s1_r <= dr_s1[cru_s0_sel];
73                     selected_s2_r <= dr_s2[cru_s0_sel];
74                     selected_s3_r <= dr_s3[cru_s0_sel];
75                     selected_s4_r <= dr_s4[cru_s1_sel];
76                     selected_s5_r <= dr_s5[cru_s1_sel];
77                     selected_s6_r <= dr_s6[cru_s1_sel];
78                     selected_s7_r <= dr_s7[cru_s1_sel];
79                 end
                   MISSING_ELSE
                   ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


263            if (!rst_n) begin
               -1-  
264                // 复位所有寄存器
265                for (j = 0; j < PARAM_DR_FP16MUL_S0_CNT; j = j + 1) begin
                   ==>
266                    dr_s0[j] <= 128'b0;
267                    dr_s1[j] <= 128'b0;
268                    dr_s2[j] <= 128'b0;
269                    dr_s3[j] <= 128'b0;
270                end
271                for (j = 0; j < PARAM_DR_FP16MUL_S1_CNT; j = j + 1) begin
272                    dr_s4[j] <= 128'b0;
273                    dr_s5[j] <= 128'b0;
274                    dr_s6[j] <= 128'b0;
275                    dr_s7[j] <= 128'b0;
276                end
277                dr_fp16mul_d0 <= 128'b0;
278                dr_fp16mul_d1 <= 128'b0;
279                dr_fp16mul_d2 <= 128'b0;
280                dr_fp16mul_d3 <= 128'b0;
281                dr_fp16mul_d4 <= 128'b0;
282                dr_fp16mul_d5 <= 128'b0;
283                dr_fp16mul_d6 <= 128'b0;
284                dr_fp16mul_d7 <= 128'b0;
285            end else begin
286                // s0123更新逻辑
287                if (cru_s0123_valid) begin
                   -2-  
288                    dr_s0[cru_s0123_reg_sel] <= dvr_fp16mul_s0;
                       ==>
289                    dr_s1[cru_s0123_reg_sel] <= dvr_fp16mul_s1;
290                    dr_s2[cru_s0123_reg_sel] <= dvr_fp16mul_s2;
291                    dr_s3[cru_s0123_reg_sel] <= dvr_fp16mul_s3;
292                end
                   MISSING_ELSE
                   ==>
293                
294                // s4567更新逻辑
295                if (cru_s4567_valid) begin
                   -3-  
296                    case (cru_s4567_low)
                       -4-  
297                        2'b00: dr_s4[cru_s4567_high] <= dvr_fp16mul_s4567;
                           ==>
298                        2'b01: dr_s5[cru_s4567_high] <= dvr_fp16mul_s4567;
                           ==>
299                        2'b10: dr_s6[cru_s4567_high] <= dvr_fp16mul_s4567;
                           ==>
300                        2'b11: dr_s7[cru_s4567_high] <= dvr_fp16mul_s4567;
                           ==>
                           MISSING_DEFAULT
                           ==>
301                    endcase
302                end
                   MISSING_ELSE
                   ==>
303                
304                // 结果写回延迟一拍，保证源选择锁存后再计算
305                if (compute_valid_r) begin
                   -5-  
306                    for (k = 0; k < PARAM_DR_FP16MUL_CNT; k = k + 1) begin
                       ==>
307                        dr_fp16mul_d0[k*4 +: 4] <= fp32_results[k][3:0];
308                        dr_fp16mul_d1[k*4 +: 4] <= fp32_results[k][7:4];
309                        dr_fp16mul_d2[k*4 +: 4] <= fp32_results[k][11:8];
310                        dr_fp16mul_d3[k*4 +: 4] <= fp32_results[k][15:12];
311                        dr_fp16mul_d4[k*4 +: 4] <= fp32_results[k][19:16];
312                        dr_fp16mul_d5[k*4 +: 4] <= fp32_results[k][23:20];
313                        dr_fp16mul_d6[k*4 +: 4] <= fp32_results[k][27:24];
314                        dr_fp16mul_d7[k*4 +: 4] <= fp32_results[k][31:28];
315                    end
316                end
                   MISSING_ELSE
                   ==>

Branches:

-1- -2- -3- -4-             -5- Status      
1   -   -   -               -   Covered     
0   1   -   -               -   Covered     
0   0   -   -               -   Covered     
0   -   1   2'b00           -   Covered     
0   -   1   2'b01           -   Covered     
0   -   1   2'b10           -   Covered     
0   -   1   2'b11           -   Covered     
0   -   1   MISSING_DEFAULT -   Not Covered 
0   -   0   -               -   Covered     
0   -   -   -               1   Covered     
0   -   -   -               0   Covered     


-------------------------------------------------------------------------------
===============================================================================
Module Instance : tb_fp16_to_fp32_multiplier.uut
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 95.43  98.33 --      95.11 --      92.86 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH 
 95.43  98.33 --      95.11 --      92.86 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                    
 95.43  98.33 --      95.11 --      92.86 fp16_to_fp32_multiplier 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH NAME                       
 79.21  94.82 --      92.81 --      50.00 tb_fp16_to_fp32_multiplier 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
