<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: tb_fp32_adder_tree_8_inputs</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | asserts</div>

</div>
<div class="ui-layout-west">
<div name='tag_tb_fp32_adder_tree_8_inputs'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_tb_fp32_adder_tree_8_inputs')">tb_fp32_adder_tree_8_inputs</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s7 cl rt"> 79.20</td>
<td class="s9 cl rt"><a href="mod4.html#Line" > 95.33</a></td>
<td class="s10 cl rt"><a href="mod4.html#Cond" >100.00</a></td>
<td class="s7 cl rt"><a href="mod4.html#Toggle" > 71.47</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod4.html#Branch" > 50.00</a></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/Sunny/SMC/05_fp32_adder_tree/sim_output/../vsrc/tb_fp32_adder_tree_8_inputs.v')">/home/Sunny/SMC/05_fp32_adder_tree/sim_output/../vsrc/tb_fp32_adder_tree_8_inputs.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod4.html#inst_tag_419"  onclick="showContent('inst_tag_419')">tb_fp32_adder_tree_8_inputs</a></td>
<td class="s7 cl rt"> 79.20</td>
<td class="s9 cl rt"><a href="mod4.html#Line" > 95.33</a></td>
<td class="s10 cl rt"><a href="mod4.html#Cond" >100.00</a></td>
<td class="s7 cl rt"><a href="mod4.html#Toggle" > 71.47</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod4.html#Branch" > 50.00</a></td>
</tr></table></div>
</div>
<br clear=all>
<div name='tag_tb_fp32_adder_tree_8_inputs'>
<hr>
<a name="inst_tag_419"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_419" >tb_fp32_adder_tree_8_inputs</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s7 cl rt"> 79.20</td>
<td class="s9 cl rt"><a href="mod4.html#Line" > 95.33</a></td>
<td class="s10 cl rt"><a href="mod4.html#Cond" >100.00</a></td>
<td class="s7 cl rt"><a href="mod4.html#Toggle" > 71.47</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod4.html#Branch" > 50.00</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s9 cl rt"> 93.92</td>
<td class="s9 cl rt"> 95.32</td>
<td class="s9 cl rt"> 90.21</td>
<td class="s9 cl rt"> 93.45</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 96.69</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<span class=inst>none</span>
<br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod0.html#inst_tag_0" id="tag_urg_inst_0">u_fp32_adder_tree_8_inputs</a></td>
<td class="s9 cl rt"> 94.27</td>
<td class="s9 cl rt"> 95.29</td>
<td class="s9 cl rt"> 90.05</td>
<td class="s9 cl rt"> 94.53</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 97.21</td>
</tr></table><br clear=all>
</div>
</div>
<hr>
Since this is the module's only instance, the coverage report is the same as for the module.</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_tb_fp32_adder_tree_8_inputs'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod4.html" >tb_fp32_adder_tree_8_inputs</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>257</td><td>245</td><td>95.33</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>92</td><td>1</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>98</td><td>1</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>101</td><td>1</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>103</td><td>1</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>123</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ROUTINE</td><td>147</td><td>18</td><td>16</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>200</td><td>12</td><td>12</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>236</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>269</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>283</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>314</td><td>17</td><td>17</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>347</td><td>77</td><td>77</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>471</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ROUTINE</td><td>484</td><td>23</td><td>21</td><td>91.30</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>537</td><td>32</td><td>32</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ROUTINE</td><td>627</td><td>11</td><td>9</td><td>81.82</td></tr>
<tr class="s9"><td class="lf">INITIAL</td><td>650</td><td>27</td><td>25</td><td>92.59</td></tr>
</table>
<pre class="code"><br clear=all>
91                          // DPI-C 导入声明
92         <font color = "red">0/1     ==>      import &quot;DPI-C&quot; function int unsigned fp32_add_8_softfloat(</font>
93                              input int unsigned input0, input int unsigned input1, 
94                              input int unsigned input2, input int unsigned input3,
95                              input int unsigned input4, input int unsigned input5, 
96                              input int unsigned input6, input int unsigned input7);
97                          
98         <font color = "red">0/1     ==>      import &quot;DPI-C&quot; function void set_softfloat_rounding_mode(</font>
99                              input int unsigned mode);
100                         
101        <font color = "red">0/1     ==>      import &quot;DPI-C&quot; function void clear_softfloat_flags();</font>
102                         
103        <font color = "red">0/1     ==>      import &quot;DPI-C&quot; function int unsigned get_softfloat_flags();</font>
104                     
105                         //==========================================================================
106                         // 被测模块实例化
107                         //==========================================================================
108                     
109                         fp32_adder_tree_8_inputs u_fp32_adder_tree_8_inputs (
110                             .clk(clk),
111                             .rst_n(rst_n),
112                             .dvr_fp32addtree8to1_s0(dvr_fp32addtree8to1_s0),
113                             .dvr_fp32addtree8to1_s1(dvr_fp32addtree8to1_s1),
114                             .cru_fp32addtree8to1(cru_fp32addtree8to1),
115                             .dr_fp32addtree8to1_d(dr_fp32addtree8to1_d)
116                         );
117                     
118                         //==========================================================================
119                         // 时钟生成
120                         //==========================================================================
121                         
122                         always begin
123        1/1                  clk = 1'b0;
124        2/2                  #(CLK_PERIOD/2);
125        1/1                  clk = 1'b1;
126        2/2                  #(CLK_PERIOD/2);
127                         end
128                     
129                         //==========================================================================
130                         // 比较函数
131                         //==========================================================================
132                         
133                         function compare_results;
134                             input [31:0] expected;
135                             input [31:0] actual;
136                             input [31:0] flags;
137                             
138                             // 局部变量声明
139                             reg temp_match_found;
140                             reg temp_is_inexact;
141                             reg temp_is_expected_nan;
142                             reg temp_is_actual_nan;
143                             reg [31:0] temp_diff;
144                             reg [31:0] temp_abs_diff;
145                             
146                             begin
147        1/1                      temp_match_found = 1'b0;
148        1/1                      temp_is_inexact = (flags &amp; 32'h00000001) != 1'b0;
149        1/1                      temp_is_expected_nan = (expected[30:23] == 8'hFF) &amp;&amp; (expected[22:0] != 23'b0);
150        1/1                      temp_is_actual_nan = (actual[30:23] == 8'hFF) &amp;&amp; (actual[22:0] != 23'b0);
151                                 
152                                 // 计算差值
153        1/1                      if (actual &gt; expected) begin
154        1/1                          temp_diff = actual - expected;
155                                 end else begin
156        1/1                          temp_diff = expected - actual;
157                                 end
158        1/1                      temp_abs_diff = temp_diff;
159                                 
160                                 // NaN 比较
161        1/1                      if (temp_is_expected_nan &amp;&amp; temp_is_actual_nan) begin
162        1/1                          temp_match_found = 1'b1;
163                                 end
164                                 // 精确匹配
165        1/1                      else if (actual === expected) begin
166        1/1                          temp_match_found = 1'b1;
167                                 end
168                                 // 不精确结果的容差比较 - 允许更大的容差
169        1/1                      else if (temp_is_inexact) begin
170                                     // 对于8输入的加法树，允许最多8 ULP的误差Units in the Last Place
171        1/1                          if (temp_abs_diff &lt;= 32'd8) begin
172        1/1                              temp_match_found = 1'b1;
173                                     end
                        MISSING_ELSE
174                                 end
175                                 // 对于非不精确结果，不允许误差 
176                                 else begin
177        <font color = "red">0/1     ==>                  if (temp_abs_diff == 32'd0) begin</font>
178        <font color = "red">0/1     ==>                      temp_match_found = 1'b1;</font>
179                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
180                                 end
181                     
182        1/1                      compare_results = temp_match_found;
183                             end
184                         endfunction
185                     
186                         // 结果打印任务
187                         task print_test_result;
188                             input integer test_num;
189                             input [31:0] expected;
190                             input [31:0] actual;
191                             input [31:0] flags;
192                             input match;
193                             input is_random;
194                             
195                             // 局部变量
196                             reg temp_is_inexact;
197                             reg [31:0] temp_diff;
198                             
199                             begin
200        1/1                      temp_is_inexact = (flags &amp; 32'h00000001) != 1'b0;
201        1/1                      if (actual &gt; expected) begin
202        1/1                          temp_diff = actual - expected;
203                                 end else begin
204        1/1                          temp_diff = expected - actual;
205                                 end
206                                 
207        1/1                      if (match) begin
208        1/1                          if (is_random &amp;&amp; (test_num % 5 != 0)) begin
209                                         // 随机测试只打印前10个和每5个
210                                     end else begin
211        1/1                              if ((expected[30:23] == 8'hFF) &amp;&amp; (expected[22:0] != 23'b0) &amp;&amp;
212                                             (actual[30:23] == 8'hFF) &amp;&amp; (actual[22:0] != 23'b0)) begin
213        1/1                                  $fdisplay(sim_log, &quot;%s %0d: PASS (NaN): expected=%h (flags=%h), actual=%h&quot;,
214                                                      is_random ? &quot;随机测试&quot; : &quot;测试用例&quot;, test_num, expected, flags, actual);
215        1/1                              end else if (actual === expected) begin
216        1/1                                  $fdisplay(sim_log, &quot;%s %0d: PASS: expected=%h (flags=%h), actual=%h&quot;,
217                                                      is_random ? &quot;随机测试&quot; : &quot;测试用例&quot;, test_num, expected, flags, actual);
218                                         end else begin
219        1/1                                  $fdisplay(sim_log, &quot;%s %0d: PASS: expected=%h (flags=%h), actual=%h (±%0d ULP tolerance)&quot;,
220                                                      is_random ? &quot;随机测试&quot; : &quot;测试用例&quot;, test_num, expected, flags, actual, temp_diff);
221                                         end
222                                     end
223                                 end else begin
224        1/1                          $fdisplay(sim_log, &quot;%s %0d: FAIL: expected=%h (flags=%h), actual=%h (diff=%0d ULP)&quot;,
225                                              is_random ? &quot;随机测试&quot; : &quot;测试用例&quot;, test_num, expected, flags, actual, temp_diff);
226                                 end
227                             end
228                         endtask
229                     
230                         // 设置测试输入任务
231                         task set_test_inputs;
232                             input integer test_case;
233                             begin
234                                 // 每个FP32数据分为高16bit(S1[y])和低16bit(S0[y])
235                                 // FP32[y] = {S1[y][15:0], S0[y][15:0]}
236        1/1                      dvr_fp32addtree8to1_s0 = {test_inputs[test_case][7][15:0],   // S0[7] - FP32[7]的低16bit
237                                                          test_inputs[test_case][6][15:0],    // S0[6] - FP32[6]的低16bit
238                                                          test_inputs[test_case][5][15:0],    // S0[5] - FP32[5]的低16bit
239                                                          test_inputs[test_case][4][15:0],    // S0[4] - FP32[4]的低16bit
240                                                          test_inputs[test_case][3][15:0],    // S0[3] - FP32[3]的低16bit
241                                                          test_inputs[test_case][2][15:0],    // S0[2] - FP32[2]的低16bit
242                                                          test_inputs[test_case][1][15:0],    // S0[1] - FP32[1]的低16bit
243                                                          test_inputs[test_case][0][15:0]};   // S0[0] - FP32[0]的低16bit
244                                 
245        1/1                      dvr_fp32addtree8to1_s1 = {test_inputs[test_case][7][31:16],  // S1[7] - FP32[7]的高16bit
246                                                          test_inputs[test_case][6][31:16],   // S1[6] - FP32[6]的高16bit
247                                                          test_inputs[test_case][5][31:16],   // S1[5] - FP32[5]的高16bit
248                                                          test_inputs[test_case][4][31:16],   // S1[4] - FP32[4]的高16bit
249                                                          test_inputs[test_case][3][31:16],   // S1[3] - FP32[3]的高16bit
250                                                          test_inputs[test_case][2][31:16],   // S1[2] - FP32[2]的高16bit
251                                                          test_inputs[test_case][1][31:16],   // S1[1] - FP32[1]的高16bit
252                                                          test_inputs[test_case][0][31:16]};  // S1[0] - FP32[0]的高16bit
253                                 
254                                 // 发送指令到目标寄存器0
255        1/1                      cru_fp32addtree8to1 = 3'b100; // 指令有效，目标寄存器编码=00
256                                 
257                                 // 等待一个时钟周期，让设计处理数据
258        2/2                      @(posedge clk);
259                                 
260                                 // 保持指令有效状态，不要立即停止
261                                 // cru_fp32addtree8to1 = 3'b0; // 注释掉，在测试完成后再停止
262                             end
263                         endtask
264                     
265                         // 测试用例初始化任务
266                         task initialize_test_cases;
267                             begin
268                                 // 基本测试用例
269        1/1                      initialize_basic_tests();
270                                 // 特殊值测试用例
271        1/1                      initialize_special_cases();
272                                 // 精度测试用例
273        1/1                      initialize_precision_cases();
274                                 // 溢出测试用例
275        1/1                      initialize_overflow_cases();
276                             end
277                         endtask
278                     
279                         // 基本测试用例初始化
280                         task initialize_basic_tests;
281                             begin
282                                 // 测试用例 0: 基本正数加法 (1+2+3+4+5+6+7+8=36)
283        1/1                      test_inputs[0][0] = 32'h3f800000; // 1.0
284        1/1                      test_inputs[0][1] = 32'h40000000; // 2.0
285        1/1                      test_inputs[0][2] = 32'h40400000; // 3.0
286        1/1                      test_inputs[0][3] = 32'h40800000; // 4.0
287        1/1                      test_inputs[0][4] = 32'h40a00000; // 5.0
288        1/1                      test_inputs[0][5] = 32'h40c00000; // 6.0
289        1/1                      test_inputs[0][6] = 32'h40e00000; // 7.0
290        1/1                      test_inputs[0][7] = 32'h41000000; // 8.0
291                     
292                                 // 测试用例 1: 正负数混合 (结果应为0)
293        1/1                      test_inputs[1][0] = 32'h41200000; // 10.0
294        1/1                      test_inputs[1][1] = 32'hc1200000; // -10.0
295        1/1                      test_inputs[1][2] = 32'h40a00000; // 5.0
296        1/1                      test_inputs[1][3] = 32'hc0a00000; // -5.0
297        1/1                      test_inputs[1][4] = 32'h3f800000; // 1.0
298        1/1                      test_inputs[1][5] = 32'hbf800000; // -1.0
299        1/1                      test_inputs[1][6] = 32'h40000000; // 2.0
300        1/1                      test_inputs[1][7] = 32'hc0000000; // -2.0
301                     
302                                 // 测试用例 2-3: 零值测试
303        1/1                      for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
304        1/1                          test_inputs[2][j] = 32'h00000000; // +0.0
305        1/1                          test_inputs[3][j] = 32'h80000000; // -0.0
306                                 end
307                             end
308                         endtask
309                     
310                         // 特殊值测试用例初始化
311                         task initialize_special_cases;
312                             begin
313                                 // 测试用例 4: 正负零混合
314        1/1                      test_inputs[4][0] = 32'h00000000; // +0.0
315        1/1                      test_inputs[4][1] = 32'h80000000; // -0.0
316        1/1                      test_inputs[4][2] = 32'h00000000; // +0.0
317        1/1                      test_inputs[4][3] = 32'h80000000; // -0.0
318        1/1                      test_inputs[4][4] = 32'h00000000; // +0.0
319        1/1                      test_inputs[4][5] = 32'h80000000; // -0.0
320        1/1                      test_inputs[4][6] = 32'h00000000; // +0.0
321        1/1                      test_inputs[4][7] = 32'h80000000; // -0.0
322                     
323                                 // 测试用例 5: 无穷大测试
324        1/1                      test_inputs[5][0] = 32'h7f800000; // +Inf
325        1/1                      for (j = 1; j &lt; NUM_INPUTS; j = j + 1) begin
326        1/1                          test_inputs[5][j] = 32'h3f800000; // 1.0
327                                 end
328                     
329                                 // 测试用例 6: 负无穷大测试
330        1/1                      test_inputs[6][0] = 32'hff800000; // -Inf
331        1/1                      for (j = 1; j &lt; NUM_INPUTS; j = j + 1) begin
332        1/1                          test_inputs[6][j] = 32'h3f800000; // 1.0
333                                 end
334                     
335                                 // 测试用例 7: NaN测试
336        1/1                      test_inputs[7][0] = 32'h7fc00000; // qNaN
337        1/1                      for (j = 1; j &lt; NUM_INPUTS; j = j + 1) begin
338        1/1                          test_inputs[7][j] = 32'h3f800000; // 1.0
339                                 end
340                             end
341                         endtask
342                     
343                         // 精度测试用例初始化
344                         task initialize_precision_cases;
345                             begin
346                                 // 测试用例 8-13: 各种精度测试
347        1/1                      for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
348        1/1                          test_inputs[8][j] = 32'h00800000;  // 最小正规格化数
349        1/1                          test_inputs[9][j] = 32'h7f7fffff;  // 最大正规格化数
350        1/1                          test_inputs[10][j] = 32'h00000001; // 最小正非规格化数
351        1/1                          test_inputs[11][j] = 32'h00000100; // 小的非规格化数
352        1/1                          test_inputs[12][j] = 32'h7f000000; // 很大的数
353        1/1                          test_inputs[13][j] = 32'h3f000000; // 0.5
354                                 end
355                                 
356                                 // 测试用例 14-20: 边界值测试
357        1/1                      test_inputs[14][0] = 32'h3f7fffff; // 接近1.0的数
358        1/1                      test_inputs[14][1] = 32'h3f800001; // 略大于1.0的数
359        1/1                      for (j = 2; j &lt; NUM_INPUTS; j = j + 1) begin
360        1/1                          test_inputs[14][j] = 32'h00000000; // 0.0
361                                 end
362                                 
363                                 // 测试用例 15: 小数加法精度测试
364        1/1                      for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
365        1/1                          test_inputs[15][j] = 32'h3e800000; // 0.25
366                                 end
367                                 
368                                 // 测试用例 16: 不同指数的数相加
369        1/1                      test_inputs[16][0] = 32'h3f800000; // 1.0
370        1/1                      test_inputs[16][1] = 32'h40000000; // 2.0
371        1/1                      test_inputs[16][2] = 32'h40800000; // 4.0
372        1/1                      test_inputs[16][3] = 32'h41000000; // 8.0
373        1/1                      test_inputs[16][4] = 32'h41800000; // 16.0
374        1/1                      test_inputs[16][5] = 32'h42000000; // 32.0
375        1/1                      test_inputs[16][6] = 32'h42800000; // 64.0
376        1/1                      test_inputs[16][7] = 32'h43000000; // 128.0
377                                 
378                                 // 测试用例 17: 很小的数相加
379        1/1                      for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
380        1/1                          test_inputs[17][j] = 32'h34000000; // 很小的正数
381                                 end
382                                 
383                                 // 测试用例 18: 正负数混合 - 应该接近零但不为零
384        1/1                      test_inputs[18][0] = 32'h41200000; // 10.0
385        1/1                      test_inputs[18][1] = 32'hc1200000; // -10.0
386        1/1                      test_inputs[18][2] = 32'h3f800000; // 1.0
387        1/1                      test_inputs[18][3] = 32'hbf800000; // -1.0
388        1/1                      test_inputs[18][4] = 32'h3e800000; // 0.25
389        1/1                      test_inputs[18][5] = 32'hbe800000; // -0.25
390        1/1                      test_inputs[18][6] = 32'h3e000000; // 0.125
391        1/1                      test_inputs[18][7] = 32'hbe000000; // -0.125
392                                 
393                                 // 测试用例 19: 非规格化数测试
394        1/1                      for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
395        1/1                          test_inputs[19][j] = 32'h00000010; // 小的非规格化数
396                                 end
397                                 
398                                 // 测试用例 20-30: 更多的精度和边界测试
399        1/1                      for (i = 20; i &lt;= 30; i = i + 1) begin
400        1/1                          for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
401                                         // 创建不同的测试模式
402        1/1                              if (i == 20) begin
403        1/1                                  test_inputs[i][j] = 32'h3dcccccd; // 0.1
404        1/1                              end else if (i == 21) begin
405        1/1                                  test_inputs[i][j] = 32'h3e4ccccd; // 0.2
406        1/1                              end else if (i == 22) begin
407        1/1                                  test_inputs[i][j] = 32'h3e99999a; // 0.3
408        1/1                              end else if (i == 23) begin
409        1/1                                  test_inputs[i][j] = 32'h3ecccccd; // 0.4
410        1/1                              end else if (i == 24) begin
411        1/1                                  test_inputs[i][j] = 32'h3f19999a; // 0.6
412        1/1                              end else if (i == 25) begin
413        1/1                                  test_inputs[i][j] = 32'h3f333333; // 0.7
414        1/1                              end else if (i == 26) begin
415        1/1                                  test_inputs[i][j] = 32'h3f4ccccd; // 0.8
416        1/1                              end else if (i == 27) begin
417        1/1                                  test_inputs[i][j] = 32'h3f666666; // 0.9
418        1/1                              end else if (i == 28) begin
419                                             // 混合正负小数
420        1/1                                  test_inputs[i][j] = (j % 2 == 0) ? 32'h3dcccccd : 32'hbdcccccd; // ±0.1
421        1/1                              end else if (i == 29) begin
422                                             // 渐增数列
423        1/1                                  case (j)
424        1/1                                      0: test_inputs[i][j] = 32'h3f800000; // 1.0
425        1/1                                      1: test_inputs[i][j] = 32'h3fc00000; // 1.5
426        1/1                                      2: test_inputs[i][j] = 32'h40000000; // 2.0
427        1/1                                      3: test_inputs[i][j] = 32'h40200000; // 2.5
428        1/1                                      4: test_inputs[i][j] = 32'h40400000; // 3.0
429        1/1                                      5: test_inputs[i][j] = 32'h40600000; // 3.5
430        1/1                                      6: test_inputs[i][j] = 32'h40800000; // 4.0
431        1/1                                      7: test_inputs[i][j] = 32'h40900000; // 4.5
                   <font color = "red">==>  MISSING_DEFAULT</font>
432                                             endcase
433                                         end else begin // i == 30
434                                             // 负数测试
435        1/1                                  test_inputs[i][j] = 32'hbf800000; // -1.0
436                                         end
437                                     end
438                                 end
439                                 
440                                 // 测试用例 31-39: 边界和特殊情况
441        1/1                      for (i = 31; i &lt; 40; i = i + 1) begin
442        1/1                          for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
443        1/1                              if (i == 31) begin
444                                             // 交替正负1
445        1/1                                  test_inputs[i][j] = (j % 2 == 0) ? 32'h3f800000 : 32'hbf800000;
446        1/1                              end else if (i == 32) begin
447                                             // 所有-1
448        1/1                                  test_inputs[i][j] = 32'hbf800000; // -1.0
449        1/1                              end else if (i == 33) begin
450                                             // 大指数差异测试
451        1/1                                  test_inputs[i][j] = (j == 0) ? 32'h47800000 : 32'h3f800000; // 65536.0 vs 1.0
452        1/1                              end else if (i == 34) begin
453                                             // Pi/8 近似值
454        1/1                                  test_inputs[i][j] = 32'h3ec90fdb; // π/8 ≈ 0.39269...
455        1/1                              end else if (i == 35) begin
456                                             // e/8 近似值
457        1/1                                  test_inputs[i][j] = 32'h3e2df854; // e/8 ≈ 0.33969...
458                                         end else begin
459                                             // 其他测试用例设为随机但固定的值
460        1/1                                  test_inputs[i][j] = 32'h3f800000 + (i * 1000 + j * 100); // 变化的值
461                                         end
462                                     end
463                                 end
464                             end
465                         endtask
466                     
467                         // 溢出测试用例初始化
468                         task initialize_overflow_cases;
469                             begin
470                                 // 测试用例 40: 溢出测试 - 应该产生INF
471        1/1                      for (j = 0; j &lt; NUM_INPUTS; j = j + 1) begin
472        1/1                          test_inputs[40][j] = 32'h7F7FFFFF; // 最大正规格化数
473                                 end
474                             end
475                         endtask
476                     
477                         //==========================================================================
478                         // 测试执行任务
479                         //==========================================================================
480                         
481                         // 执行固定测试用例
482                         task execute_fixed_tests;
483                             begin
484        1/1                      $fdisplay(sim_log, &quot;\n=== Starting Fixed Test Cases ===&quot;);
485                     
486        1/1                      for (i = 0; i &lt; NUM_FIXED_TESTS; i = i + 1) begin
487                                     // 设置输入
488        1/1                          set_test_inputs(i);
489                     
490                                     // 清除 SoftFloat 异常标志
491        1/1                          clear_softfloat_flags();
492                     
493                                     // 通过 DPI-C 从 SoftFloat 获取期望结果
494        1/1                          expected_fp32_from_softfloat = fp32_add_8_softfloat(
495                                         test_inputs[i][0], test_inputs[i][1], test_inputs[i][2], test_inputs[i][3],
496                                         test_inputs[i][4], test_inputs[i][5], test_inputs[i][6], test_inputs[i][7]);
497        1/1                          softfloat_flags = get_softfloat_flags();
498                     
499                                     // 等待DUT处理（等待时钟和寄存器更新）
500        2/2                          @(posedge clk);
501        2/2                          #1; // 小延迟确保信号稳定
502                                     
503                                     // 停止指令
504        1/1                          cru_fp32addtree8to1 = 3'b0;
505                     
506                                     // 比较结果
507        1/1                          match_found = compare_results(expected_fp32_from_softfloat, fp_sum, softfloat_flags);
508                     
509                                     // 打印结果
510        1/1                          print_test_result(i, expected_fp32_from_softfloat, fp_sum, softfloat_flags, match_found, 1'b0);
511                     
512                                     // 更新计数器
513        1/1                          if (match_found) begin
514        1/1                              pass_count = pass_count + 1;
515                                     end else begin
516        <font color = "red">0/1     ==>                      fail_count = fail_count + 1;</font>
517                                         // 输出输入值用于调试
518        <font color = "red">0/1     ==>                      $fdisplay(sim_log, &quot;输入: %h %h %h %h %h %h %h %h&quot;,</font>
519                                                  test_inputs[i][0], test_inputs[i][1], test_inputs[i][2], test_inputs[i][3],
520                                                  test_inputs[i][4], test_inputs[i][5], test_inputs[i][6], test_inputs[i][7]);
521                                     end
522                     
523        2/2                          #10;
524                                 end
525                     
526                                 // 输出固定测试统计信息
527        1/1                      $fdisplay(sim_log, &quot;\nFixed Test Cases Summary:&quot;);
528        1/1                      $fdisplay(sim_log, &quot;Total fixed tests: %0d&quot;, pass_count + fail_count);
529        1/1                      $fdisplay(sim_log, &quot;Passed: %0d&quot;, pass_count);
530        1/1                      $fdisplay(sim_log, &quot;Failed: %0d&quot;, fail_count);
531                             end
532                         endtask
533                     
534                         // 执行随机测试
535                         task execute_random_tests;
536                             begin
537        1/1                      $fdisplay(sim_log, &quot;\n=== Starting Random Tests ===&quot;);
538                     
539                                 // 初始化随机测试计数器
540        1/1                      random_pass_count = 0;
541        1/1                      random_fail_count = 0;
542                     
543                                 // 初始化随机种子
544        1/1                      $srandom(RANDOM_SEED);
545                     
546        1/1                      for (rand_i = 0; rand_i &lt; NUM_RANDOM_TESTS; rand_i = rand_i + 1) begin
547                                     // 生成随机输入
548        1/1                          for (rand_j = 0; rand_j &lt; NUM_INPUTS; rand_j = rand_j + 1) begin
549        1/1                              random_inputs[rand_j] = $random;
550                                     end
551                     
552                                     // 设置输入到DUT - 按照新接口规范：每个FP32分为高低16bit
553        1/1                          dvr_fp32addtree8to1_s0 = {random_inputs[7][15:0],   // S0[7] - FP32[7]的低16bit
554                                                              random_inputs[6][15:0],    // S0[6] - FP32[6]的低16bit
555                                                              random_inputs[5][15:0],    // S0[5] - FP32[5]的低16bit
556                                                              random_inputs[4][15:0],    // S0[4] - FP32[4]的低16bit
557                                                              random_inputs[3][15:0],    // S0[3] - FP32[3]的低16bit
558                                                              random_inputs[2][15:0],    // S0[2] - FP32[2]的低16bit
559                                                              random_inputs[1][15:0],    // S0[1] - FP32[1]的低16bit
560                                                              random_inputs[0][15:0]};   // S0[0] - FP32[0]的低16bit
561                                     
562        1/1                          dvr_fp32addtree8to1_s1 = {random_inputs[7][31:16],  // S1[7] - FP32[7]的高16bit
563                                                              random_inputs[6][31:16],   // S1[6] - FP32[6]的高16bit
564                                                              random_inputs[5][31:16],   // S1[5] - FP32[5]的高16bit
565                                                              random_inputs[4][31:16],   // S1[4] - FP32[4]的高16bit
566                                                              random_inputs[3][31:16],   // S1[3] - FP32[3]的高16bit
567                                                              random_inputs[2][31:16],   // S1[2] - FP32[2]的高16bit
568                                                              random_inputs[1][31:16],   // S1[1] - FP32[1]的高16bit
569                                                              random_inputs[0][31:16]};  // S1[0] - FP32[0]的高16bit
570                                     
571                                     // 发送指令到目标寄存器0
572        1/1                          cru_fp32addtree8to1 = 3'b100; // 指令有效，目标寄存器编码=00
573                     
574                                     // 清除 SoftFloat 异常标志
575        1/1                          clear_softfloat_flags();
576                     
577                                     // 通过 DPI-C 从 SoftFloat 获取期望结果
578        1/1                          random_expected = fp32_add_8_softfloat(
579                                         random_inputs[0], random_inputs[1], random_inputs[2], random_inputs[3],
580                                         random_inputs[4], random_inputs[5], random_inputs[6], random_inputs[7]);
581        1/1                          random_flags = get_softfloat_flags();
582                     
583                                     // 等待DUT处理（等待时钟和寄存器更新）
584        2/2                          @(posedge clk);
585        2/2                          #1; // 小延迟确保信号稳定
586                                     
587                                     // 停止指令
588        1/1                          cru_fp32addtree8to1 = 3'b0;
589                     
590                                     // 比较结果
591        1/1                          match_found = compare_results(random_expected, fp_sum, random_flags);
592                     
593                                     // 打印结果（有选择性地）
594        1/1                          print_test_result(rand_i, random_expected, fp_sum, random_flags, match_found, 1'b1);
595                     
596                                     // 更新计数器
597        1/1                          if (match_found) begin
598        1/1                              random_pass_count = random_pass_count + 1;
599                                     end else begin
600        1/1                              random_fail_count = random_fail_count + 1;
601                                         // 输出输入值用于调试
602        1/1                              $fdisplay(sim_log, &quot;输入: %h %h %h %h %h %h %h %h&quot;,
603                                                  random_inputs[0], random_inputs[1], random_inputs[2], random_inputs[3],
604                                                  random_inputs[4], random_inputs[5], random_inputs[6], random_inputs[7]);
605                                     end
606                     
607        2/2                          #1; // 较短的延迟以加快随机测试
608                     
609                                 end
610                     
611                                 // 输出随机测试统计信息
612        1/1                      $fdisplay(sim_log, &quot;\nRandom Test Summary:&quot;);
613        1/1                      $fdisplay(sim_log, &quot;Total random tests: %0d&quot;, random_pass_count + random_fail_count);
614        1/1                      $fdisplay(sim_log, &quot;Passed: %0d&quot;, random_pass_count);
615        1/1                      $fdisplay(sim_log, &quot;Failed: %0d&quot;, random_fail_count);
616        1/1                      if (NUM_RANDOM_TESTS &gt; 0) begin
617        1/1                          $fdisplay(sim_log, &quot;Pass rate: %0d/%0d (%.1f%%)&quot;,
618                                              random_pass_count, NUM_RANDOM_TESTS,
619                                              (random_pass_count * 100.0) / NUM_RANDOM_TESTS);
620                                 end
                   <font color = "red">==>  MISSING_ELSE</font>
621                             end
622                         endtask
623                     
624                         // 打印最终统计信息
625                         task print_final_statistics;
626                             begin
627        1/1                      $fdisplay(sim_log, &quot;\n=== Overall Test Summary ===&quot;);
628        1/1                      $fdisplay(sim_log, &quot;Fixed tests - Passed: %0d, Failed: %0d&quot;, pass_count, fail_count);
629        1/1                      $fdisplay(sim_log, &quot;Random tests - Passed: %0d, Failed: %0d&quot;, random_pass_count, random_fail_count);
630        1/1                      $fdisplay(sim_log, &quot;Total tests: %0d&quot;, pass_count + fail_count + random_pass_count + random_fail_count);
631        1/1                      $fdisplay(sim_log, &quot;Total passed: %0d&quot;, pass_count + random_pass_count);
632        1/1                      $fdisplay(sim_log, &quot;Total failed: %0d&quot;, fail_count + random_fail_count);
633                     
634        1/1                      if ((fail_count + random_fail_count) == 0) begin
635        <font color = "red">0/1     ==>                  $fdisplay(sim_log, &quot;\nPASSED: All test cases passed!&quot;);</font>
636        <font color = "red">0/1     ==>                  $display(&quot;SIMULATION PASSED: All test cases passed!&quot;);</font>
637                                 end else begin
638        1/1                          $fdisplay(sim_log, &quot;\nFAILED: %0d test cases failed&quot;, fail_count + random_fail_count);
639        1/1                          $display(&quot;SIMULATION FAILED: %0d test cases failed&quot;, fail_count + random_fail_count);
640                                 end
641                             end
642                         endtask
643                     
644                         //==========================================================================
645                         // 主测试序列
646                         //==========================================================================
647                         
648                         initial begin
649                             // 初始化信号
650        1/1                  clk = 1'b0;
651        1/1                  rst_n = 1'b0;
652        1/1                  dvr_fp32addtree8to1_s0 = 128'b0;
653        1/1                  dvr_fp32addtree8to1_s1 = 128'b0;
654        1/1                  cru_fp32addtree8to1 = 3'b0;
655        1/1                  pass_count = 0;
656        1/1                  fail_count = 0;
657                     
658                             // 波形文件设置
659                             `ifdef DUMP_FSDB
660        1/1                      $fsdbDumpfile(&quot;sim_softfloat.fsdb&quot;);
661        1/1                      $fsdbDumpvars(0, tb_fp32_adder_tree_8_inputs);
662        1/1                      $display(&quot;FSDB波形文件已启用: sim_softfloat.fsdb&quot;);
663                             `endif
664                     
665                             // 日志文件设置
666        1/1                  sim_log = $fopen(&quot;sim_softfloat.log&quot;, &quot;w&quot;);
667        1/1                  if (sim_log == 0) begin
668        <font color = "red">0/1     ==>              $display(&quot;Error: Could not open sim_softfloat.log&quot;);</font>
669        <font color = "red">0/1     ==>              $finish;</font>
670                             end
                        MISSING_ELSE
671        1/1                  $fdisplay(sim_log, &quot;FP32 Adder Tree SoftFloat Simulation started at time %t&quot;, $time);
672                     
673                             // 设置 SoftFloat 舍入模式
674        1/1                  set_softfloat_rounding_mode(SOFTFLOAT_ROUND_NEAR_EVEN);
675                     
676                             // 初始化测试用例数据
677        1/1                  initialize_test_cases();
678                     
679                             // 系统复位
680        2/2                  #20;
681        1/1                  rst_n = 1'b1;
682        2/2                  #10;
683                     
684                             // 执行固定测试用例
685        1/1                  execute_fixed_tests();
686                     
687                             // 执行随机测试
688        1/1                  execute_random_tests();
689                     
690                             // 输出最终统计
691        1/1                  print_final_statistics();
692                     
693                             // 清理并结束仿真
694        1/1                  $fclose(sim_log);
695        1/1                  $finish;
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a href="mod4.html" >tb_fp32_adder_tree_8_inputs</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s10"><td class="lf">Conditions</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">Logical</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       60
 EXPRESSION ((fp_sum[30:23] == 8'hff) &amp;&amp; (fp_sum[22:0] != 23'b0))
             ------------1-----------    -----------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       61
 EXPRESSION ((fp_sum[30:23] == 8'hff) &amp;&amp; (fp_sum[22:0] == 23'b0))
             ------------1-----------    -----------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod4.html" >tb_fp32_adder_tree_8_inputs</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s6">
<td>Totals</td>
<td class="rt">14</td>
<td class="rt">9</td>
<td class="rt">64.29 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">1104</td>
<td class="rt">789</td>
<td class="rt">71.47 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">552</td>
<td class="rt">395</td>
<td class="rt">71.56 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 1->0</td>
<td class="rt">552</td>
<td class="rt">394</td>
<td class="rt">71.38 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Signals</td>
<td class="rt">14</td>
<td class="rt">9</td>
<td class="rt">64.29 </td>
</tr><tr class="s7">
<td>Signal Bits</td>
<td class="rt">1104</td>
<td class="rt">789</td>
<td class="rt">71.47 </td>
</tr><tr class="s7">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">552</td>
<td class="rt">395</td>
<td class="rt">71.56 </td>
</tr><tr class="s7">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">552</td>
<td class="rt">394</td>
<td class="rt">71.38 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dvr_fp32addtree8to1_s0[127:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dvr_fp32addtree8to1_s1[127:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>cru_fp32addtree8to1[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>cru_fp32addtree8to1[2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dr_fp32addtree8to1_d[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dr_fp32addtree8to1_d[127:32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fp_sum[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_nan_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_inf_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>match_found</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>expected_fp32_from_softfloat[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>softfloat_flags[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>softfloat_flags[1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>softfloat_flags[2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>softfloat_flags[31:3]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>random_expected[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>random_flags[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>random_flags[1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>random_flags[2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>random_flags[3]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>random_flags[4]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>random_flags[31:5]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod4.html" >tb_fp32_adder_tree_8_inputs</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">667</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
667                if (sim_log == 0) begin
                   <font color = "red">-1-</font>  
668                    $display("Error: Could not open sim_softfloat.log");
           <font color = "red">            ==></font>
669                    $finish;
670                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_419">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
  <ul name="tag_tb_fp32_adder_tree_8_inputs">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
