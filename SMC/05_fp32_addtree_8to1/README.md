# FP32 8输入加法器树设计规格书

## 1. 概述

### 1.1 项目描述
本项目实现了一个高性能的IEEE 754单精度浮点（FP32）8输入加法器树，能够同时对8个32位浮点数进行并行累加运算。设计采用华莱士树（Wallace Tree）架构实现高效的多输入并行累加，具有完整的IEEE 754标准兼容性和特殊值处理能力。

### 1.2 设计目标
- **高性能**: 采用华莱士树结构实现8个FP32数的高效并行累加
- **IEEE 754兼容**: 完全遵循IEEE 754-2008单精度浮点标准
- **特殊值处理**: 正确处理±0、±∞、NaN、非规格化数等特殊值
- **高精度**: 使用扩展精度位和保护位确保计算精度
- **寄存器接口**: 提供标准化的寄存器式输入输出接口

## 2. 架构设计

### 2.1 顶层架构

```
输入接口层 → 数据解包层 → 对齐层 → 华莱士树累加层 → 规格化舍入层 → 输出打包层
    ↓            ↓         ↓         ↓             ↓           ↓
  寄存器式     FP32解包   指数对齐   正负分离累加    规格化舍入   结果选择输出
   输入接口    特殊值检测  尾数对齐   华莱士树加法    IEEE舍入    寄存器输出
```

### 2.2 核心模块组成

| 模块名称 | 功能描述 | 输入 | 输出 |
|---------|---------|------|------|
| `fp32_unpacker` | FP32解包和特殊值检测 | 32位FP32数据 | 符号、指数、尾数、特殊值标志 |
| `fp32_aligner` | 指数对齐和尾数扩展 | 8组解包数据 | 最大指数、对齐后尾数 |
| `wallace_tree_8_inputs` | 华莱士树累加器 | 8个扩展精度数据 | 累加结果 |
| `fp32_normalizer_rounder` | 规格化和舍入 | 原始累加结果 | 规格化FP32结果 |
| `fp32_packer` | 结果打包 | 符号、指数、尾数 | 最终FP32输出 |

## 3. 接口规格

### 3.1 模块接口定义

module fp32_adder_tree_8_inputs (
    input wire clk,                                      // 时钟信号
    input wire rst_n,                                    // 低电平有效复位
    input wire [127:0] dvr_fp32addtree8to1_s0,          // 输入数据寄存器0（低16位）
    input wire [127:0] dvr_fp32addtree8to1_s1,          // 输入数据寄存器1（高16位）
    input wire [2:0] cru_fp32addtree8to1,               // 指令控制寄存器
    
    output reg [127:0] dr_fp32addtree8to1_d              // 输出数据寄存器
);

### 3.2 输入接口详述

#### 3.2.1 数据输入接口
- **dvr_fp32addtree8to1_s0[127:0]**: 8个FP32数据的低16位组合
  - `s0[15:0]`: FP32[0]的低16位
  - `s0[31:16]`: FP32[1]的低16位
  - `s0[47:32]`: FP32[2]的低16位
  - ...
  - `s0[127:112]`: FP32[7]的低16位

- **dvr_fp32addtree8to1_s1[127:0]**: 8个FP32数据的高16位组合
  - `s1[15:0]`: FP32[0]的高16位
  - `s1[31:16]`: FP32[1]的高16位
  - `s1[47:32]`: FP32[2]的高16位
  - ...
  - `s1[127:112]`: FP32[7]的高16位

- **数据重组**: FP32[i] = {s1[16*(i+1)-1:16*i], s0[16*(i+1)-1:16*i]}

#### 3.2.2 控制接口
- **cru_fp32addtree8to1[2:0]**: 指令控制寄存器
  - `bit[2]`: 指令有效位（cmd_valid）
    - 1'b1: 执行加法运算
    - 1'b0: 不执行运算
  - `bit[1:0]`: 目的寄存器索引（dest_reg_idx）
    - 2'b00: 结果存储到输出寄存器的[31:0]位段
    - 2'b01: 结果存储到输出寄存器的[63:32]位段
    - 2'b10: 结果存储到输出寄存器的[95:64]位段
    - 2'b11: 结果存储到输出寄存器的[127:96]位段

### 3.3 输出接口
- **dr_fp32addtree8to1_d[127:0]**: 输出数据寄存器
  - 128位寄存器可存储4个32位结果
  - 根据dest_reg_idx选择存储位置
  - 非目标位段保持为0

## 4. 算法实现

```
1. 数据预处理阶段
   ├── 输入数据重组：S0+S1 → 8个完整FP32数据
   ├── FP32解包：提取符号、指数、尾数
   └── 特殊值检测：识别±0、±∞、NaN

2. 对齐阶段  
   ├── 寻找最大指数：max_exponent = max(exp[0]...exp[7])
   ├── 尾数右移对齐：mant[i] >> (max_exp - exp[i])
   └── 添加保护位：Guard + Round + Sticky + 额外精度位

3. 符号处理阶段
   ├── 正数组：effective_sign = 0 的尾数
   ├── 负数组：effective_sign = 1 的尾数  
   └── 扩展到FULL_SUM_WIDTH位宽

4. 华莱士树累加阶段
   ├── 正数华莱士树：8个正数 → pos_sum
   ├── 负数华莱士树：8个负数 → neg_sum
   └── 结果相减：final_result = pos_sum - neg_sum

5. 规格化舍入阶段
   ├── 符号确定：基于final_result和输入分析
   ├── 尾数规格化：移位到标准形式
   ├── 指数调整：补偿移位造成的指数变化
   └── IEEE舍入：就近偶数舍入

6. 特殊值处理阶段
   ├── NaN传播：任意输入NaN → 输出NaN
   ├── 无穷大处理：±∞输入的特殊逻辑
   ├── 溢出处理：结果过大 → ±∞
   └── 下溢处理：结果过小 → 非规格化数或±0

7. 结果输出阶段
   ├── 最终打包：组装符号、指数、尾数
   └── 寄存器写入：根据dest_reg_idx存储结果
```

## 5. 技术参数

| 参数名称 | 数值 | 说明 |
|---------|------|------|
| FP32_WIDTH | 32 | IEEE 754单精度总位宽 |
| FP32_EXP_WIDTH | 8 | 指数位宽 |
| FP32_MANT_WIDTH | 23 | 尾数位宽 |
| FP32_BIAS | 127 | 指数偏置值 |
| GUARD_BITS | 6 | 保护位数量（G+R+S+额外精度） |
| ALIGNED_MANT_WIDTH | 30 | 对齐后尾数位宽（1+23+6） |
| FULL_SUM_WIDTH | 34 | 累加器位宽 |


## 6. 验证策略

### 6.1 验证环境
- **参考模型**: Berkeley SoftFloat-3库
- **验证平台**: Verilog + DPI-C
- **舍入模式**: IEEE 754就近偶数舍入

### 6.2 验收标准
- 固定测试用例100%通过
- 随机测试通过率≥99.9%
- 特殊值处理100%正确


## 快速入门指南

### 1. 克隆项目
```bash
git clone git@github.com:seclabBupt/aiacc.git
cd SMC/05_fp32_adder_tree
```

### 2. 运行仿真
```bash
chmod +x run_sim_softfloat.sh
./run_sim_softfloat.sh
```

### 3. 查看结果
```bash
# 查看仿真日志
cat sim_softfloat.log

# 使用波形查看器
verdi -ssf sim_softfloat.fsdb
```
