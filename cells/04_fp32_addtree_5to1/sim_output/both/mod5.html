<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: fp32_normalizer_rounder</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | asserts</div>

</div>
<div class="ui-layout-west">
<div name='tag_fp32_normalizer_rounder'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_fp32_normalizer_rounder')">fp32_normalizer_rounder</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s9 cl rt"> 90.70</td>
<td class="s9 cl rt"><a href="mod5.html#Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#Cond" > 77.78</a></td>
<td class="s9 cl rt"><a href="mod5.html#Toggle" > 92.17</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#Branch" > 94.12</a></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/Sunny/SMC/04_fp32_addtree_5to1/sim_output/../vsrc/fp32_normalizer_rounder.v')">/home/Sunny/SMC/04_fp32_addtree_5to1/sim_output/../vsrc/fp32_normalizer_rounder.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left class="sortable">
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1546"  onclick="showContent('inst_tag_1546')">tb_fp32_addtree_5to1.dut.gen_tree[0].normalizer_inst</a></td>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1546_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1546_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1546_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1546_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1547"  onclick="showContent('inst_tag_1547')">tb_fp32_addtree_5to1.dut.gen_tree[1].normalizer_inst</a></td>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1547_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1547_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1547_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1547_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1549"  onclick="showContent('inst_tag_1549')">tb_fp32_addtree_5to1.dut.gen_tree[3].normalizer_inst</a></td>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1549_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1549_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1549_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1549_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1551"  onclick="showContent('inst_tag_1551')">tb_fp32_addtree_5to1.dut.gen_tree[5].normalizer_inst</a></td>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1551_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1551_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1551_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1551_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1552"  onclick="showContent('inst_tag_1552')">tb_fp32_addtree_5to1.dut.gen_tree[6].normalizer_inst</a></td>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1552_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1552_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1552_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1552_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1553"  onclick="showContent('inst_tag_1553')">tb_fp32_addtree_5to1.dut.gen_tree[7].normalizer_inst</a></td>
<td class="s8 cl rt"> 89.57</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1553_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1553_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1553_Toggle" > 87.68</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1553_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1548"  onclick="showContent('inst_tag_1548')">tb_fp32_addtree_5to1.dut.gen_tree[2].normalizer_inst</a></td>
<td class="s9 cl rt"> 90.04</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1548_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1548_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1548_Toggle" > 89.57</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1548_Branch" > 94.12</a></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_1550"  onclick="showContent('inst_tag_1550')">tb_fp32_addtree_5to1.dut.gen_tree[4].normalizer_inst</a></td>
<td class="s9 cl rt"> 90.62</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1550_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1550_Cond" > 77.78</a></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1550_Toggle" > 91.88</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1550_Branch" > 94.12</a></td>
</tr></table></div>
</div>
<br clear=all>
<div name='inst_tag_1546'>
<hr>
<a name="inst_tag_1546"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1546" >tb_fp32_addtree_5to1.dut.gen_tree[0].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1546_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1546_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1546_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1546_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 87.25</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1547'>
<hr>
<a name="inst_tag_1547"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1547" >tb_fp32_addtree_5to1.dut.gen_tree[1].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1547_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1547_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1547_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1547_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 87.25</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1549'>
<hr>
<a name="inst_tag_1549"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1549" >tb_fp32_addtree_5to1.dut.gen_tree[3].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1549_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1549_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1549_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1549_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 87.25</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1551'>
<hr>
<a name="inst_tag_1551"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1551" >tb_fp32_addtree_5to1.dut.gen_tree[5].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1551_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1551_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1551_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1551_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 87.25</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1552'>
<hr>
<a name="inst_tag_1552"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1552" >tb_fp32_addtree_5to1.dut.gen_tree[6].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1552_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1552_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1552_Toggle" > 87.25</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1552_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.46</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 87.25</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1553'>
<hr>
<a name="inst_tag_1553"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1553" >tb_fp32_addtree_5to1.dut.gen_tree[7].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.57</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1553_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1553_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1553_Toggle" > 87.68</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1553_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s8 cl rt"> 89.57</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 87.68</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1548'>
<hr>
<a name="inst_tag_1548"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1548" >tb_fp32_addtree_5to1.dut.gen_tree[2].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s9 cl rt"> 90.04</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1548_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1548_Cond" > 77.78</a></td>
<td class="s8 cl rt"><a href="mod5.html#inst_tag_1548_Toggle" > 89.57</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1548_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s9 cl rt"> 90.04</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s8 cl rt"> 89.57</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_1550'>
<hr>
<a name="inst_tag_1550"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy1.html#tag_urg_inst_1550" >tb_fp32_addtree_5to1.dut.gen_tree[4].normalizer_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s9 cl rt"> 90.62</td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1550_Line" > 98.72</a></td>
<td class="s7 cl rt"><a href="mod5.html#inst_tag_1550_Cond" > 77.78</a></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1550_Toggle" > 91.88</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod5.html#inst_tag_1550_Branch" > 94.12</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td class="s9 cl rt"> 90.62</td>
<td class="s9 cl rt"> 98.72</td>
<td class="s7 cl rt"> 77.78</td>
<td class="s9 cl rt"> 91.88</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.12</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s9 cl rt"> 99.03</td>
<td class="s10 cl rt">100.00</td>
<td class="s9 cl rt"> 97.92</td>
<td class="s9 cl rt"> 98.21</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td><a href="mod0.html#inst_tag_0" >dut</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td></tr><tr>
<td colspan=7>no children</td>
</tr></table><br clear=all>
</div>
</div>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_fp32_normalizer_rounder'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod5.html" >fp32_normalizer_rounder</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a href="mod5.html" >fp32_normalizer_rounder</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod5.html" >fp32_normalizer_rounder</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">636</td>
<td class="rt">92.17 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">318</td>
<td class="rt">92.17 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">318</td>
<td class="rt">92.17 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s9">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">484</td>
<td class="rt">90.30 </td>
</tr><tr class="s9">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">242</td>
<td class="rt">90.30 </td>
</tr><tr class="s9">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">242</td>
<td class="rt">90.30 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[10:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[11]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[14:12]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[15]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[19:16]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[20]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[21]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[23]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod5.html" >fp32_normalizer_rounder</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1546'>
<a name="inst_tag_1546_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1546" >tb_fp32_addtree_5to1.dut.gen_tree[0].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1546_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1546" >tb_fp32_addtree_5to1.dut.gen_tree[0].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1546_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1546" >tb_fp32_addtree_5to1.dut.gen_tree[0].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">602</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">450</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[3:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1546_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1546" >tb_fp32_addtree_5to1.dut.gen_tree[0].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1547'>
<a name="inst_tag_1547_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1547" >tb_fp32_addtree_5to1.dut.gen_tree[1].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1547_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1547" >tb_fp32_addtree_5to1.dut.gen_tree[1].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1547_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1547" >tb_fp32_addtree_5to1.dut.gen_tree[1].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">602</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">450</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[3:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1547_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1547" >tb_fp32_addtree_5to1.dut.gen_tree[1].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1549'>
<a name="inst_tag_1549_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1549" >tb_fp32_addtree_5to1.dut.gen_tree[3].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1549_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1549" >tb_fp32_addtree_5to1.dut.gen_tree[3].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1549_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1549" >tb_fp32_addtree_5to1.dut.gen_tree[3].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">602</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">450</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[3:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1549_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1549" >tb_fp32_addtree_5to1.dut.gen_tree[3].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1551'>
<a name="inst_tag_1551_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1551" >tb_fp32_addtree_5to1.dut.gen_tree[5].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1551_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1551" >tb_fp32_addtree_5to1.dut.gen_tree[5].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1551_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1551" >tb_fp32_addtree_5to1.dut.gen_tree[5].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">602</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">450</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[3:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1551_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1551" >tb_fp32_addtree_5to1.dut.gen_tree[5].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1552'>
<a name="inst_tag_1552_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1552" >tb_fp32_addtree_5to1.dut.gen_tree[6].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1552_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1552" >tb_fp32_addtree_5to1.dut.gen_tree[6].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1552_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1552" >tb_fp32_addtree_5to1.dut.gen_tree[6].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">602</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">301</td>
<td class="rt">87.25 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">450</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">225</td>
<td class="rt">83.96 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[3:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1552_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1552" >tb_fp32_addtree_5to1.dut.gen_tree[6].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1553'>
<a name="inst_tag_1553_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1553" >tb_fp32_addtree_5to1.dut.gen_tree[7].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1553_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1553" >tb_fp32_addtree_5to1.dut.gen_tree[7].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1553_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1553" >tb_fp32_addtree_5to1.dut.gen_tree[7].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">605</td>
<td class="rt">87.68 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">306</td>
<td class="rt">88.70 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">299</td>
<td class="rt">86.67 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">453</td>
<td class="rt">84.51 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">230</td>
<td class="rt">85.82 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">223</td>
<td class="rt">83.21 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[2:1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_mant[27:3]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[3:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[6:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[9:7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[10]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[15:11]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[17:16]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[18]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[19]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:20]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1553_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1553" >tb_fp32_addtree_5to1.dut.gen_tree[7].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1548'>
<a name="inst_tag_1548_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1548" >tb_fp32_addtree_5to1.dut.gen_tree[2].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1548_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1548" >tb_fp32_addtree_5to1.dut.gen_tree[2].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1548_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1548" >tb_fp32_addtree_5to1.dut.gen_tree[2].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s8">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">618</td>
<td class="rt">89.57 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">309</td>
<td class="rt">89.57 </td>
</tr><tr class="s8">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">309</td>
<td class="rt">89.57 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">466</td>
<td class="rt">86.94 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">233</td>
<td class="rt">86.94 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">233</td>
<td class="rt">86.94 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[4:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[6:5]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[8:7]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[11:9]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[13:12]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[16:14]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[18:17]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[22:19]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[23]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1548_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1548" >tb_fp32_addtree_5to1.dut.gen_tree[2].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_1550'>
<a name="inst_tag_1550_Line"></a>
<b>Line Coverage for Instance : <a href="mod5.html#inst_tag_1550" >tb_fp32_addtree_5to1.dut.gen_tree[4].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s9"><td class="lf">TOTAL</td><td></td><td>78</td><td>77</td><td>98.72</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>64</td><td>30</td><td>30</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>130</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>162</td><td>34</td><td>33</td><td>97.06</td></tr>
</table>
<pre class="code"><br clear=all>
63                          // 初始化默认值
64         1/1              zero_out = 1'b0;
65         1/1              overflow = 1'b0;
66         1/1              underflow = 1'b0;
67         1/1              adjusted_exp = {(`FP32_EXP_WIDTH+1){1'b0}};
68         1/1              normalized_mant = {NORM_MANT_WIDTH{1'b0}};
69         1/1              current_msb_pos = -1;
70         1/1              sticky = 1'b0;
71                          
72                          // 判断输入是否为非规格化数：指数为0且尾数不为0
73         1/1              is_denorm_input = (exp_in == 0 &amp;&amp; mant_raw != 0);
74                          
75                          // 扩展尾数以便处理
76         1/1              extended_mant = {mant_raw, {`GUARD_BITS{1'b0}}}; 
77                      
78                          // 检查是否为零
79         1/1              if (mant_raw == 0) begin
80         1/1                  zero_out = 1'b1;
81                          end else begin
82                              // 查找最高有效位（MSB）位置
83         1/1                  current_msb_pos = IN_WIDTH - 1;
84         1/1                  while (current_msb_pos &gt;= 0 &amp;&amp; !mant_raw[current_msb_pos]) begin
85         1/1                      current_msb_pos = current_msb_pos - 1;
86                              end
                   <font color = "red">==>  WHILE_FALSE</font>
87                      
88                              // 计算规格化所需的移位量
89         1/1                  logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                              
91                              // 执行规格化移位
92         1/1                  if (logical_shift &gt; 0) begin 
93                                  // 右移：计算被移出的sticky位
94         1/1                      temp_sticky = 1'b0;
95         1/1                      for (sticky_i = 0; sticky_i &lt; logical_shift; sticky_i = sticky_i + 1) begin
96         1/1                          if (sticky_i &lt; (IN_WIDTH + `GUARD_BITS)) begin
97         1/1                              temp_sticky = temp_sticky | extended_mant[sticky_i];
98                                      end
                   <font color = "red">==>  MISSING_ELSE</font>
99                                  end
100        1/1                      sticky = temp_sticky;
101        1/1                      normalized_mant = extended_mant &gt;&gt; logical_shift;
102        1/1                  end else if (logical_shift &lt; 0) begin 
103                                 // 左移
104        1/1                      normalized_mant = extended_mant &lt;&lt; (-logical_shift);
105                             end else begin
106                                 // 无需移位
107        1/1                      normalized_mant = extended_mant;
108                             end
109                     
110                             // 指数调整逻辑
111        1/1                  if (is_denorm_input) begin
112                                 // 对于非规格化数输入的特殊处理
113        1/1                      if (current_msb_pos &lt; TARGET_POS - 1) begin
114        1/1                          adjusted_exp = 0; // 结果依然是非规格化数
115                                 end else begin
116        1/1                          adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
117                                 end
118                             end else begin
119                                 // 对于规格化数输入，正常调整指数
120        1/1                      adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
121                             end
122                         end
123                     end
124                     
125                     //=============================================================================
126                     // 舍入逻辑（Round to Nearest Even）
127                     //=============================================================================
128                     always @(*) begin
129                         // 提取23位尾数作为初始值
130        1/1              rounded_mant = normalized_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
131        1/1              final_exp = adjusted_exp;
132        1/1              carry_out_rounding = 1'b0;
133                     
134        1/1              if (!zero_out) begin
135                             // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136        1/1                  g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137        1/1                  r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138        1/1                  s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139        1/1                  lsb = rounded_mant[0];                             // 最低有效位
140                     
141                             // Round to Nearest Even判断：
142                             // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                             // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144        1/1                  round_up = (g &amp; (r | s)) | (g &amp; ~r &amp; ~s &amp; lsb);
145                     
146        1/1                  if (round_up) begin
147        1/1                      {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                                 
149                                 // 处理舍入进位
150        1/1                      if (carry_out_rounding) begin
151        1/1                          rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
152        1/1                          final_exp = final_exp + 1;
153                                 end
                        MISSING_ELSE
154                             end
                        MISSING_ELSE
155                         end
                        MISSING_ELSE
156                     end
157                     
158                     //=============================================================================
159                     // 最终结果封装
160                     //=============================================================================
161                     always @(*) begin
162        1/1              if (zero_out) begin
163                             // 零的情况
164        1/1                  fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
165        1/1                  underflow = 1'b0;
166        1/1                  overflow = 1'b0;
167                             
168        1/1              end else if (final_exp &gt;= EXP_MAX) begin
169                             // 上溢：输出无穷大
170        1/1                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
171        1/1                  overflow = 1'b1;
172        1/1                  underflow = 1'b0;
173                             
174        1/1              end else if (final_exp &lt;= 0) begin
175                             // 下溢：处理次正规数
176        1/1                  underflow = 1'b1;
177        1/1                  overflow = 1'b0;
178                             
179        1/1                  if (is_denorm_input &amp;&amp; final_exp == 0) begin
180                                 // 输入为非规格化数且结果仍为非规格化数的情况
181        1/1                      denorm_shifted = mant_raw &gt;&gt; `GUARD_BITS;
182        1/1                      fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                             end else begin 
184                                 // 其他下溢情况：执行次正规数舍入
185        1/1                      denorm_shift = 1 - final_exp;
186        1/1                      denorm_mant = normalized_mant;
187                                 
188                                 // 计算被移出的额外sticky位
189        1/1                      temp_sticky = 1'b0;
190        1/1                      for (sticky_i = 0; sticky_i &lt; denorm_shift; sticky_i = sticky_i + 1) begin
191        1/1                          if (sticky_i &lt; NORM_MANT_WIDTH) begin
192        1/1                              temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                                     end
                   <font color = "red">==>  MISSING_ELSE</font>
194                                 end
195                                 
196                                 // 执行次正规数右移
197        1/1                      denorm_mant = denorm_mant &gt;&gt; denorm_shift;
198                                 
199                                 // 在次正规数窗口执行舍入
200        1/1                      dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201        1/1                      dn_g = denorm_mant[`GUARD_BITS-1];
202        1/1                      dn_r = denorm_mant[`GUARD_BITS-2];
203        1/1                      dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204        1/1                      dn_lsb = dn_mant24_pre[0];
205                     
206        1/1                      dn_round_up = (dn_g &amp; (dn_r | dn_s)) | (dn_g &amp; ~dn_r &amp; ~dn_s &amp; dn_lsb);
207        1/1                      {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208                     
209        1/1                      if (dn_carry24) begin
210                                     // 次正规数舍入进位：升级为最小正规数
211        <font color = "red">0/1     ==>                  fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};</font>
212                                 end else begin
213                                     // 保持次正规数
214        1/1                          fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
215                                 end
216                             end
217                             
218                         end else begin
219                             // 正常数
220        1/1                  fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
221        1/1                  underflow = 1'b0;
222        1/1                  overflow = 1'b0;
</pre>
<hr>
<a name="inst_tag_1550_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod5.html#inst_tag_1550" >tb_fp32_addtree_5to1.dut.gen_tree[4].normalizer_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">Conditions</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s7"><td class="lf">Logical</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       73
 EXPRESSION ((exp_in == 8'b0) &amp;&amp; (mant_raw != 0))
             --------1-------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       84
 EXPRESSION ((current_msb_pos &gt;= 0) &amp;&amp; ((!mant_raw[current_msb_pos])))
             -----------1----------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       179
 EXPRESSION (is_denorm_input &amp;&amp; (final_exp == 9'b0))
             -------1-------    ---------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_1550_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod5.html#inst_tag_1550" >tb_fp32_addtree_5to1.dut.gen_tree[4].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s7">
<td>Totals</td>
<td class="rt">32</td>
<td class="rt">25</td>
<td class="rt">78.12 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">690</td>
<td class="rt">634</td>
<td class="rt">91.88 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">345</td>
<td class="rt">317</td>
<td class="rt">91.88 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">345</td>
<td class="rt">317</td>
<td class="rt">91.88 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s8">
<td>Ports</td>
<td class="rt">7</td>
<td class="rt">6</td>
<td class="rt">85.71 </td>
</tr><tr class="s9">
<td>Port Bits</td>
<td class="rt">154</td>
<td class="rt">152</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 0->1</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr><tr class="s9">
<td nowrap>Port Bits 1->0</td>
<td class="rt">77</td>
<td class="rt">76</td>
<td class="rt">98.70 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s7">
<td>Signals</td>
<td class="rt">25</td>
<td class="rt">19</td>
<td class="rt">76.00 </td>
</tr><tr class="s8">
<td>Signal Bits</td>
<td class="rt">536</td>
<td class="rt">482</td>
<td class="rt">89.93 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">268</td>
<td class="rt">241</td>
<td class="rt">89.93 </td>
</tr><tr class="s8">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">268</td>
<td class="rt">241</td>
<td class="rt">89.93 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>mant_raw[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>mant_raw[32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>exp_in[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sign_in</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>fp_out[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>zero_out</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>fp_out_reg[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>adjusted_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>normalized_mant[29:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extended_mant[37:6]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>extended_mant[38]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rounded_mant[22:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>final_exp[8:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>carry_out_rounding</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[27:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_mant[29:28]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_pre[21:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_mant24_pre[23:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dn_mant24_rounded[23:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_g</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_r</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_s</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_lsb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_round_up</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>dn_carry24</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>temp_sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>sticky</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>is_denorm_input</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[10:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[11]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[14:12]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[15]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[19:16]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[20]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[21]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[24:22]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>denorm_shifted[25]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>denorm_shifted[32:26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_1550_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod5.html#inst_tag_1550" >tb_fp32_addtree_5to1.dut.gen_tree[4].normalizer_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Branches</td>
<td></td>
<td class="rt">17</td>
<td class="rt">16</td>
<td class="rt">94.12 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">79</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">134</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">162</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
79             if (mant_raw == 0) begin
               <font color = "green">-1-</font>  
80                 zero_out = 1'b1;
           <font color = "green">        ==></font>
81             end else begin
82                 // 查找最高有效位（MSB）位置
83                 current_msb_pos = IN_WIDTH - 1;
84                 while (current_msb_pos >= 0 && !mant_raw[current_msb_pos]) begin
85                     current_msb_pos = current_msb_pos - 1;
86                 end
87         
88                 // 计算规格化所需的移位量
89                 logical_shift = current_msb_pos - (TARGET_POS - 1); 
90                 
91                 // 执行规格化移位
92                 if (logical_shift > 0) begin 
                   <font color = "green">-2-</font>              
93                     // 右移：计算被移出的sticky位
94                     temp_sticky = 1'b0;
           <font color = "green">            ==></font>
95                     for (sticky_i = 0; sticky_i < logical_shift; sticky_i = sticky_i + 1) begin
96                         if (sticky_i < (IN_WIDTH + `GUARD_BITS)) begin
97                             temp_sticky = temp_sticky | extended_mant[sticky_i];
98                         end
99                     end
100                    sticky = temp_sticky;
101                    normalized_mant = extended_mant >> logical_shift;
102                end else if (logical_shift < 0) begin 
                            <font color = "green">-3-</font>              
103                    // 左移
104                    normalized_mant = extended_mant << (-logical_shift);
           <font color = "green">            ==></font>
105                end else begin
106                    // 无需移位
107                    normalized_mant = extended_mant;
           <font color = "green">            ==></font>
108                end
109        
110                // 指数调整逻辑
111                if (is_denorm_input) begin
                   <font color = "green">-4-</font>  
112                    // 对于非规格化数输入的特殊处理
113                    if (current_msb_pos < TARGET_POS - 1) begin
                       <font color = "green">-5-</font>  
114                        adjusted_exp = 0; // 结果依然是非规格化数
           <font color = "green">                ==></font>
115                    end else begin
116                        adjusted_exp = 1 + logical_shift - `GUARD_BITS; // 非规格化数变为规格化数
           <font color = "green">                ==></font>
117                    end
118                end else begin
119                    // 对于规格化数输入，正常调整指数
120                    adjusted_exp = exp_in + logical_shift - `GUARD_BITS;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
134            if (!zero_out) begin
               <font color = "green">-1-</font>  
135                // 提取Guard, Round, Sticky, LSB位（使用前3个guard bits进行舍入）
136                g   = normalized_mant[`GUARD_BITS-1];              // Guard位（第5位）
137                r   = normalized_mant[`GUARD_BITS-2];              // Round位（第4位）
138                s   = |normalized_mant[`GUARD_BITS-3:0] | sticky; // Sticky位（第3位及以下）+ 移位sticky
139                lsb = rounded_mant[0];                             // 最低有效位
140        
141                // Round to Nearest Even判断：
142                // 1. G=1 且 (R=1 或 S=1)：向上舍入
143                // 2. G=1, R=0, S=0, LSB=1：向上舍入（偶数对齐）
144                round_up = (g & (r | s)) | (g & ~r & ~s & lsb);
145        
146                if (round_up) begin
                   <font color = "green">-2-</font>  
147                    {carry_out_rounding, rounded_mant} = rounded_mant + 1;
148                    
149                    // 处理舍入进位
150                    if (carry_out_rounding) begin
                       <font color = "green">-3-</font>  
151                        rounded_mant = {1'b1, {`FP32_MANT_WIDTH-1{1'b0}}};
           <font color = "green">                ==></font>
152                        final_exp = final_exp + 1;
153                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
154                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
155            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
162            if (zero_out) begin
               <font color = "green">-1-</font>  
163                // 零的情况
164                fp_out_reg = {sign_in, ZERO_EXP, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
165                underflow = 1'b0;
166                overflow = 1'b0;
167                
168            end else if (final_exp >= EXP_MAX) begin
                        <font color = "green">-2-</font>  
169                // 上溢：输出无穷大
170                fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b1}}, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "green">        ==></font>
171                overflow = 1'b1;
172                underflow = 1'b0;
173                
174            end else if (final_exp <= 0) begin
                        <font color = "green">-3-</font>  
175                // 下溢：处理次正规数
176                underflow = 1'b1;
177                overflow = 1'b0;
178                
179                if (is_denorm_input && final_exp == 0) begin
                   <font color = "green">-4-</font>  
180                    // 输入为非规格化数且结果仍为非规格化数的情况
181                    denorm_shifted = mant_raw >> `GUARD_BITS;
           <font color = "green">            ==></font>
182                    fp_out_reg = {sign_in, ZERO_EXP, denorm_shifted[`FP32_MANT_WIDTH-1:0]};
183                end else begin 
184                    // 其他下溢情况：执行次正规数舍入
185                    denorm_shift = 1 - final_exp;
186                    denorm_mant = normalized_mant;
187                    
188                    // 计算被移出的额外sticky位
189                    temp_sticky = 1'b0;
190                    for (sticky_i = 0; sticky_i < denorm_shift; sticky_i = sticky_i + 1) begin
191                        if (sticky_i < NORM_MANT_WIDTH) begin
192                            temp_sticky = temp_sticky | denorm_mant[sticky_i];
193                        end
194                    end
195                    
196                    // 执行次正规数右移
197                    denorm_mant = denorm_mant >> denorm_shift;
198                    
199                    // 在次正规数窗口执行舍入
200                    dn_mant24_pre = denorm_mant[NORM_MANT_WIDTH-1:`GUARD_BITS];
201                    dn_g = denorm_mant[`GUARD_BITS-1];
202                    dn_r = denorm_mant[`GUARD_BITS-2];
203                    dn_s = (|denorm_mant[`GUARD_BITS-3:0]) | temp_sticky;
204                    dn_lsb = dn_mant24_pre[0];
205        
206                    dn_round_up = (dn_g & (dn_r | dn_s)) | (dn_g & ~dn_r & ~dn_s & dn_lsb);
207                    {dn_carry24, dn_mant24_rounded} = dn_mant24_pre + (dn_round_up ? 1'b1 : 1'b0);
208        
209                    if (dn_carry24) begin
                       <font color = "red">-5-</font>  
210                        // 次正规数舍入进位：升级为最小正规数
211                        fp_out_reg = {sign_in, {`FP32_EXP_WIDTH{1'b0}} | 8'd1, {`FP32_MANT_WIDTH{1'b0}}};
           <font color = "red">                ==></font>
212                    end else begin
213                        // 保持次正规数
214                        fp_out_reg = {sign_in, ZERO_EXP, dn_mant24_rounded[`FP32_MANT_WIDTH-1:0]};
           <font color = "green">                ==></font>
215                    end
216                end
217                
218            end else begin
219                // 正常数
220                fp_out_reg = {sign_in, final_exp[`FP32_EXP_WIDTH-1:0], rounded_mant};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_1546">
    <li>
      <a href="#inst_tag_1546_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1546_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1546_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1546_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1547">
    <li>
      <a href="#inst_tag_1547_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1547_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1547_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1547_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1548">
    <li>
      <a href="#inst_tag_1548_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1548_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1548_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1548_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1549">
    <li>
      <a href="#inst_tag_1549_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1549_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1549_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1549_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1550">
    <li>
      <a href="#inst_tag_1550_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1550_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1550_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1550_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1551">
    <li>
      <a href="#inst_tag_1551_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1551_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1551_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1551_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1552">
    <li>
      <a href="#inst_tag_1552_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1552_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1552_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1552_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_1553">
    <li>
      <a href="#inst_tag_1553_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_1553_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_1553_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_1553_Branch">Branch</a>    </li>
  </ul>
  <ul name="tag_fp32_normalizer_rounder">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
